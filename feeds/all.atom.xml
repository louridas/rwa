<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Real World Algorithms Web Companion</title><link href="https://louridas.github.io/" rel="alternate"></link><link href="https://louridas.github.io/feeds/all.atom.xml" rel="self"></link><id>https://louridas.github.io/</id><updated>2022-05-29T00:00:00+03:00</updated><entry><title>Samuel Beckett and Gray Codes</title><link href="https://louridas.github.io/assignments/samuel-beckett-and-gray-codes/" rel="alternate"></link><published>2022-05-29T00:00:00+03:00</published><updated>2022-05-29T00:00:00+03:00</updated><author><name>Panos Louridas</name></author><id>tag:louridas.github.io,2022-05-29:/assignments/samuel-beckett-and-gray-codes/</id><summary type="html">&lt;p&gt;The best known work of Irish writer Samuel Beckett (1906--1989, Nobel
prize in Literature 1969) is the play "Waiting for Godot". Beckett,
who lived in Paris for the largest part of his life, wrote it first in
French in 1952 (En attendant Godot) and then in English in 1954. In …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The best known work of Irish writer Samuel Beckett (1906--1989, Nobel
prize in Literature 1969) is the play "Waiting for Godot". Beckett,
who lived in Paris for the largest part of his life, wrote it first in
French in 1952 (En attendant Godot) and then in English in 1954. In
the play, the two main characters, Vladimir and Estragon, are, per the
title, waiting for Godot. We don't know why. While waiting they talk
and meet with others. The play ends but Godot has not come. They will
continue to wait for him.&lt;/p&gt;
&lt;p&gt;In this assignment we will deal with another one, lesser known play by
Beckett, written for the television. In this play, called "Quad",
there are four characters. Beckett wanted them to appear on stage with
a specific way. Only on character may enter or exit at a certain
point and the character who exits must be the one that has been on
stage the longest. Moreover, Beckett wanted during the play to appear
all possible combinations of the four characters, exactly once.&lt;/p&gt;
&lt;p&gt;He was not able to find a way to do that. Indeed, it is impossible to
achieve such a sequence of entrances and exits for four characters
without repeating some of the combinations.&lt;/p&gt;
&lt;p&gt;Let us now return to Computer Science. The &lt;a href="https://en.wikipedia.org/wiki/Gray_code"&gt;Gray
code&lt;/a&gt; with &lt;span class="math"&gt;\(n\)&lt;/span&gt; bits is a
cyclical ordering of the binary numbers with &lt;span class="math"&gt;\(n\)&lt;/span&gt; bits so that two
successive values differ by one bit. For instance, the Gray code for
&lt;span class="math"&gt;\(n = 4\)&lt;/span&gt; is:&lt;/p&gt;
&lt;p&gt;0000, 0001, 0011, 0010, 0110, 0111, 0101, 0100, 1100, 1101, 1111,
1110, 1010, 1011, 1001, 1000.&lt;/p&gt;
&lt;p&gt;Note that each number differs both from the previous one and the one
that comes next by one bit. Also, this holds for the last number in
the sequence if we take as next the first number in the sequence, so
the code is cyclical.&lt;/p&gt;
&lt;p&gt;It is easy to construct such a code with &lt;span class="math"&gt;\(n\)&lt;/span&gt; bits, working
recursively. If with &lt;span class="math"&gt;\(\Gamma_n\)&lt;/span&gt; we denote the Gray code with &lt;span class="math"&gt;\(n\)&lt;/span&gt; bits
and &lt;span class="math"&gt;\(\Gamma_0\)&lt;/span&gt; is the empty string, then to construct the Gray code
with &lt;span class="math"&gt;\(n+1\)&lt;/span&gt; bits we only need to take the Gray code with &lt;span class="math"&gt;\(n\)&lt;/span&gt; bits,
prefix each string with &lt;span class="math"&gt;\(0\)&lt;/span&gt;, reverse it, and then prefix each string
of the reversed sequence with &lt;span class="math"&gt;\(1\)&lt;/span&gt;. Indeed:&lt;/p&gt;
&lt;div class="math"&gt;$$\Gamma_1 = 0, 1$$&lt;/div&gt;
&lt;p&gt;We just prefixed the empty string with &lt;span class="math"&gt;\(1\)&lt;/span&gt; and &lt;span class="math"&gt;\(0\)&lt;/span&gt;. Then:&lt;/p&gt;
&lt;div class="math"&gt;$$\Gamma_2 = 00, 01, 11, 10$$&lt;/div&gt;
&lt;p&gt;We prefixed each string of &lt;span class="math"&gt;\(0, 1\)&lt;/span&gt; with &lt;span class="math"&gt;\(0\)&lt;/span&gt; and then we prefixed each
string of the sequence &lt;span class="math"&gt;\(1, 0\)&lt;/span&gt; with &lt;span class="math"&gt;\(1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Similarly:&lt;/p&gt;
&lt;div class="math"&gt;$$\Gamma_3 = 000, 001, 011, 010, 110, 111, 101, 100$$&lt;/div&gt;
&lt;p&gt;We prefixed each string of &lt;span class="math"&gt;\(00, 01, 11, 10\)&lt;/span&gt; with &lt;span class="math"&gt;\(0\)&lt;/span&gt; and each string
&lt;span class="math"&gt;\(10, 11, 01, 00\)&lt;/span&gt; with &lt;span class="math"&gt;\(1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;From the way it is built, this code is called, if we want to be more
precise, Reflected Binary Code (RBC), or Reflected Binary (RB). &lt;/p&gt;
&lt;p&gt;But note that we can have a code that meets the requirement of
changing a single bit each time without building it in this way. For
instance, in the &lt;em&gt;balanced Gray code&lt;/em&gt;, we want to have the same number
of changes for each bit. Here is a balanced Gray code of four bits:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{matrix}
0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0
&amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; \boxed{0}\\ 
0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; \boxed{1}
&amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp;
\boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0\\
\boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp;
\boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1
\end{matrix}
$$&lt;/div&gt;
&lt;p&gt;Each item of the code corresponds to a column. You can verify that in
each row we have four bits changing in total.&lt;/p&gt;
&lt;p&gt;By adopting other requirements we can create different Gray codes. We
can also drop the requirement for the code to be cyclical. If it is
not, we say that the code is a path, but not a cycle.&lt;/p&gt;
&lt;p&gt;If we adopt the requirement that want the bit that changes to zero to
be the bit that has remained for longer with value one, then the
resulting code meets the criterion set by Beckett&amp;ndash;and,
therefore, it is a Beckett-Gray code.&lt;/p&gt;
&lt;p&gt;For &lt;span class="math"&gt;\(n = 3\)&lt;/span&gt; there is no Beckett-Gray code, because it is not possible
to find a cyclical code that meets the Beckett requirement; there is,
however, a single path:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{matrix}
0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1\\
0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 1\\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1
\end{matrix}
$$&lt;/div&gt;
&lt;p&gt;You can verify that the bit that goes off in a column is the one that
has stayed on for longest in its row.&lt;/p&gt;
&lt;p&gt;For &lt;span class="math"&gt;\(n = 4\)&lt;/span&gt;, again, there is no Beckett-Gray code, so it's no surprise
that Beckett could not find one for his play. But there are four paths:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{matrix}
0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1
&amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 1\\
0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1
&amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1\\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1
&amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0\\ 
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 1 &amp;amp; 1
&amp;amp; 1 &amp;amp; 1
\end{matrix}
$$&lt;/div&gt;
&lt;hr/&gt;

&lt;div class="math"&gt;$$
\begin{matrix}
0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1
&amp;amp; 1 &amp;amp; 1\\
0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1
&amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1
&amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0\\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1
\end{matrix}
$$&lt;/div&gt;
&lt;hr/&gt;

&lt;div class="math"&gt;$$
\begin{matrix}
0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp;
\boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\
0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1
&amp;amp; 1 &amp;amp; 1\\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1
&amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0\\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1
\end{matrix}
$$&lt;/div&gt;
&lt;hr/&gt;

&lt;div class="math"&gt;$$
\begin{matrix}
0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1\\
0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp;
\boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1
&amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0\\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \boxed{1} &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \boxed{0} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1\\
\end{matrix}
$$&lt;/div&gt;
&lt;p&gt;For &lt;span class="math"&gt;\(n = 5\)&lt;/span&gt; there are 16 Beckett-Gray codes. At this point, let's
introduce a more practical way to represent Gray codes and paths. As
only a single bit changes each time, to represent a Gray code or path
we only need to give the sequence of bits that change, where each bit
is represented by its position, counting from the right. That is
called &lt;em&gt;delta sequence&lt;/em&gt; or &lt;em&gt;transition sequence&lt;/em&gt; and we denote it with
&lt;span class="math"&gt;\(\delta\)&lt;/span&gt;. So, for the Gray cycle with &lt;span class="math"&gt;\(1\)&lt;/span&gt; bit we have &lt;span class="math"&gt;\(\delta = 00\)&lt;/span&gt;
and for the Gray cycle with &lt;span class="math"&gt;\(2\)&lt;/span&gt; bits we have &lt;span class="math"&gt;\(\delta = 0101\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Proceeding to &lt;span class="math"&gt;\(n = 3\)&lt;/span&gt;, for the Gray cycle that we obtain by closing 
&lt;span class="math"&gt;\(\Gamma_3\)&lt;/span&gt; we have &lt;span class="math"&gt;\(\delta = 01020102\)&lt;/span&gt;, while there exists also
amother Gray cycle (which is not reflected) with &lt;span class="math"&gt;\(\delta = 01210121\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Using delta sequences, the 16 Beckett-Gray codes for &lt;span class="math"&gt;\(n = 5\)&lt;/span&gt; are:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{matrix}
01020132010432104342132340412304 &amp;amp; 01020312403024041232414013234013\\
01020314203024041234214103234103 &amp;amp; 01020314203240421034214130324103\\
01020341202343142320143201043104 &amp;amp; 01023412032403041230341012340124\\
01201321402314340232134021431041 &amp;amp; 01203041230314043210403202413241\\
01203104213043421310342104302402 &amp;amp; 01230121430214340230341420314121\\
01230124234140231410343201434204 &amp;amp; 01230401231340413234202341024212\\
01230401232430423134101432014121 &amp;amp; 01230412320434120343014312041323\\
01234010232430124313401432014121 &amp;amp; 01234010232430201432014132413141\\
\end{matrix}
$$&lt;/div&gt;
&lt;p&gt;Gray codes have an interpretation using graphs and geometry. If we
create a graph whose vertices are the elements of the code and the
edges connect two elements that differ by a single bit, then the
possible paths and cycles are the various ways to explore the graph
starting from a different edge of the graph. A path that covers all
the vertices exactly once is called a &lt;em&gt;Hamiltonian path&lt;/em&gt; and a cycle
that visits all the vertices exactly once is called a &lt;em&gt;Hamiltonian
cycle&lt;/em&gt;. Given that each vertex has exactly &lt;span class="math"&gt;\(n\)&lt;/span&gt; neighbors, such a
graph, in geometrical terms, is a &lt;em&gt;hypercube&lt;/em&gt;. Below you can see the
hypercuble for &lt;span class="math"&gt;\(n = 4\)&lt;/span&gt; and a Hamiltonian cycle on it. The Hamiltonian
cycle corresponds to the reflective Gray code for &lt;span class="math"&gt;\(n = 4\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/samuel-beckett-and-gray-codes/hypercube.png" width="500"/&gt;&lt;/p&gt;
&lt;p&gt;If we want to find all Gray codes, it suffices to find all paths and
cycles on the corresponding graph (or hypercube). However, some of the
resulting codes can be derived from other codes by just permutating
the bit positions. To see that, we will need some definitions. Let us
call &lt;em&gt;coordinates&lt;/em&gt; the elements of a delta sequence: for &lt;span class="math"&gt;\(n=3\)&lt;/span&gt; the
coordinates are &lt;span class="math"&gt;\(0, 1, 2\)&lt;/span&gt;. We will denote by &lt;span class="math"&gt;\(d(n)\)&lt;/span&gt; the number of
different delta sequences for a given &lt;span class="math"&gt;\(n\)&lt;/span&gt;. We will denote by &lt;span class="math"&gt;\(c(n)\)&lt;/span&gt;
the number of canonical delta sequences, in which each coordinate &lt;span class="math"&gt;\(k\)&lt;/span&gt;
appears in the sequence before the first appearance of coordinate
&lt;span class="math"&gt;\(k+1\)&lt;/span&gt;. As every permutation of the coordinates of a delta sequence
produces another delta sequence, we have &lt;span class="math"&gt;\(d(n) = n!c(n)\)&lt;/span&gt;. Indeed, we
saw that for &lt;span class="math"&gt;\(\Gamma_3\)&lt;/span&gt; we have &lt;span class="math"&gt;\(\delta = 01020102\)&lt;/span&gt;. If we apply the
permutation:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{pmatrix}
0 &amp;amp; 1 &amp;amp; 2\\
1 &amp;amp; 0 &amp;amp; 2
\end{pmatrix}
$$&lt;/div&gt;
&lt;p&gt;we obtain &lt;span class="math"&gt;\(\delta = 10121012\)&lt;/span&gt;, which you can verify that it is a Gray
code, but the delta sequence is not canonical as &lt;span class="math"&gt;\(1\)&lt;/span&gt; appears in it
before &lt;span class="math"&gt;\(0\)&lt;/span&gt;. If a Gray code can be obtained by another one through
permutation, we say that the two codes are &lt;em&gt;isomorphic&lt;/em&gt;. To find all
the non-isomorphic Gray codes, we must ensure that when exploring the
Hamiltonian paths and cycles our trail follows only canonical delta
sequences. &lt;/p&gt;
&lt;p&gt;We know that in order to explore a graph, we can use depth-first
search. Here we will use a variant of depth-first search that will
have the following characteristics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The exploration will proceed from node to node of the hypercube. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;At each node, we note the largest coordinate that we can change. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The neighbors of the node are produced from the current node by
  a bit at a time, starting from the least significant one (the first
  from the right, at position zero), until the largest coordinate.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In traditional depth-first search, we note each node that we visit
  so that we do not visit it again. In this way we explore the graph
  only once. Here, though, we want to explore the graph exhaustively,
  finding all possible paths that meet our requirements. That means
  that we must take care so that once we have explored a path we can
  re-visit its nodes (in a different order).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can achieve the above with the algorithm that follows. The
algorithm builds Gray codes one at a time using the stack
&lt;span class="math"&gt;\(\mathit{gc}\)&lt;/span&gt; and it collects them in the list &lt;span class="math"&gt;\(\mathit{all\_codes}\)&lt;/span&gt;,
which is initially empty. To call the algorithm, we must initialize
the array &lt;span class="math"&gt;\(\mathit{visited}\)&lt;/span&gt; with all its elements set to
\textsc{false}, apart from from &lt;span class="math"&gt;\(\mathit{visited}[0]\)&lt;/span&gt; which will be
set to \textsc{true}; the &lt;span class="math"&gt;\(\mathit{gc}\)&lt;/span&gt; stack will initially contain
element &lt;span class="math"&gt;\(0\)&lt;/span&gt;. The algorithm's parameters include the recursion depth,
&lt;span class="math"&gt;\(d\)&lt;/span&gt;, starting from &lt;span class="math"&gt;\(d = 1\)&lt;/span&gt;, so that we can define the condition to
stop the recursion---when we have visited all &lt;span class="math"&gt;\(2^n\)&lt;/span&gt; nodes of the
hypercube. The algorithm uses function \textsf{Flip(}&lt;span class="math"&gt;\(x\)&lt;/span&gt;,
&lt;span class="math"&gt;\(i\)&lt;/span&gt;\textsf{)}, which changes the value of bit &lt;span class="math"&gt;\(i\)&lt;/span&gt; in &lt;span class="math"&gt;\(x\)&lt;/span&gt;. When we
start &lt;span class="math"&gt;\(x\)&lt;/span&gt; is zero, while &lt;span class="math"&gt;\(\mathit{max\_coord}\)&lt;/span&gt;, as we don't want to
use a coordinate before we use the smaller coordinates, is also zero.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/samuel-beckett-and-gray-codes/dfs_gray.png" width="700"/&gt;&lt;/p&gt;
&lt;p&gt;This algorithm will produce all Gray codes. That is not enough for us:
we want to be able to produce the Beckett-Gray codes. To achieve that,
we need to modify the algorithm a little. We will use a queue so that
we will know that when we set a bit to zero, that will be the bit
whose value has stayed at one for the longest time. &lt;/p&gt;
&lt;p&gt;The algorithm ensures that we will find the Gray codes that are not
isomorphic due to permutations. We can extend the definition of
isomorphism between Gray codes to include codes that can be derived
from one another via reversal, and not just permutation. For example,
let's take the first Beckett-Gray code for &lt;span class="math"&gt;\(n = 5\)&lt;/span&gt; that we saw before:&lt;/p&gt;
&lt;div class="math"&gt;$$ 
01020132010432104342132340412304 
$$&lt;/div&gt;
&lt;p&gt;This code is isomorphic with:&lt;/p&gt;
&lt;div class="math"&gt;$$
01234010232430201432014132413141
$$&lt;/div&gt;
&lt;p&gt;Indeed, if we reverse it, we get:&lt;/p&gt;
&lt;div class="math"&gt;$$
14131423141023410203423201043210
$$&lt;/div&gt;
&lt;p&gt;But from code:&lt;/p&gt;
&lt;div class="math"&gt;$$
01020132010432104342132340412304
$$&lt;/div&gt;
&lt;p&gt;we can derive code:&lt;/p&gt;
&lt;div class="math"&gt;$$
14131423141023410203423201043210
$$&lt;/div&gt;
&lt;p&gt;with the permutation:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{pmatrix}
0 &amp;amp; 1 &amp;amp; 2 &amp;amp; 3 &amp;amp; 4\\
1 &amp;amp; 4 &amp;amp; 3 &amp;amp; 2 &amp;amp; 0
\end{pmatrix}
$$&lt;/div&gt;
&lt;p&gt;In this assignment you will write a program that will produce various
kinds of Gray codes and will find any isomorphisms that can be
obtained via reversals and permutations.&lt;/p&gt;
&lt;h2&gt;Requirements&lt;/h2&gt;
&lt;p&gt;You will write a program called &lt;code&gt;beckectt_gray.py&lt;/code&gt;. You may use the
following libraries:
&lt;a href="https://docs.python.org/3/library/itertools.html"&gt;&lt;code&gt;itertools&lt;/code&gt;&lt;/a&gt;,
&lt;a href="https://docs.python.org/3/library/argparse.html"&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; or
&lt;a href="https://docs.python.org/3/library/sys.html"&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; (in particular,
the list &lt;code&gt;sys.argv&lt;/code&gt;) to handle program arguments.&lt;/p&gt;
&lt;p&gt;Your program will be called as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python beckett_gray.py &lt;span class="o"&gt;[&lt;/span&gt;-a &lt;span class="p"&gt;|&lt;/span&gt; -b &lt;span class="p"&gt;|&lt;/span&gt; -u &lt;span class="p"&gt;|&lt;/span&gt; -c &lt;span class="p"&gt;|&lt;/span&gt; -p&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-r&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-f&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-m&lt;span class="o"&gt;]&lt;/span&gt; number_of_bits
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The program will take the following arguments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-a&lt;/code&gt;: find all codes (cycles and paths)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-b&lt;/code&gt;: find Beckett-Gray codes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-u&lt;/code&gt;: find Beckett-Gray paths (not cyles) &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-c&lt;/code&gt;: find cyclical codes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;: find Gray paths&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-r&lt;/code&gt;: find reverse isomorphisms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-f&lt;/code&gt;: show the full binary representation of each code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-m&lt;/code&gt;: show each code with a tabular representation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;number_of_bits&lt;/code&gt;: the number of bits of the code&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The meaning of the arguments is illustrated in the examples that
follow. &lt;/p&gt;
&lt;h3&gt;Examples&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Example 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python beckett_gray.py -a &lt;span class="m"&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;or simply:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python beckett_gray.py &lt;span class="m"&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the program will produce the following output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;C 01020102
P 0102101
C 01210121
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It found three codes, presented with their delta sequences. Two of the
codes are cyclical (prefixed with &lt;code&gt;C&lt;/code&gt;) and one is a path (prefixed
with &lt;code&gt;P&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python beckett_gray.py -b &lt;span class="m"&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the program will produce the following output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;B 01020132010432104342132340412304
B 01020312403024041232414013234013
B 01020314203024041234214103234103
B 01020314203240421034214130324103
B 01020341202343142320143201043104
B 01023412032403041230341012340124
B 01201321402314340232134021431041
B 01203041230314043210403202413241
B 01203104213043421310342104302402
B 01230121430214340230341420314121
B 01230124234140231410343201434204
B 01230401231340413234202341024212
B 01230401232430423134101432014121
B 01230412320434120343014312041323
B 01234010232430124313401432014121
B 01234010232430201432014132413141
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;that is, it found 16 Beckett-Gray codes (prefixed with &lt;code&gt;B&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python beckett_gray.py -b &lt;span class="m"&gt;5&lt;/span&gt; -r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the program will output the contents of the file
&lt;a href="https://louridas.github.io/rwa/assignments/beckett-gray/bgc_5_isomorphic.txt"&gt;&lt;code&gt;bgc_5_isomorphic.txt&lt;/code&gt;&lt;/a&gt;
that is, as in the previous example but adding in the end the reversed
isomorphisms. &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python beckett_gray.py -c &lt;span class="m"&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the program will output the contents of the file 
το πρόγραμμα θα εμφανίσει στην έξοδο τα περιεχόμενα του αρχείου 
&lt;a href="https://louridas.github.io/rwa/assignments/beckett-gray/gc_4_cycles.txt"&gt;&lt;code&gt;gc_4_cycles.txt&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 5&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python beckett_gray.py -u &lt;span class="m"&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the program will output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;U 0102101
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;that is, a path (the only one for &lt;span class="math"&gt;\(n = 3\)&lt;/span&gt;) that fulfils Beckett's
requirement, hence the prefix &lt;code&gt;U&lt;/code&gt; (unfinished, as it ends without
closing the cycle).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 6&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python beckett_gray.py -u &lt;span class="m"&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the program will produce the following output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;U 010213202313020
U 010213212031321
U 012301202301230
U 012301213210321
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Example 7&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python beckett_gray.py -b -f &lt;span class="m"&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the program will output the contents of the file
&lt;a href="https://louridas.github.io/rwa/assignments/beckett-gray/bgc_5_full.txt"&gt;&lt;code&gt;bgc_5_full.txt&lt;/code&gt;&lt;/a&gt;;
that is, except from the delta sequence it will also output the full
binary representation of each code.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 8&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python beckett_gray.py -u -m &lt;span class="m"&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the program will output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;U 010213202313020
0 1 1 0 0 0 0 0 1 1 1 1 1 0 0 1
0 0 1 1 1 0 0 0 0 0 0 1 1 1 1 1
0 0 0 0 1 1 1 0 0 1 1 1 1 1 0 0
0 0 0 0 0 0 1 1 1 1 0 0 1 1 1 1
U 010213212031321
0 1 1 0 0 0 0 0 0 0 1 1 1 1 1 1
0 0 1 1 1 0 0 0 1 1 1 1 0 0 0 1
0 0 0 0 1 1 1 0 0 1 1 1 1 1 0 0
0 0 0 0 0 0 1 1 1 1 1 0 0 1 1 1
U 012301202301230
0 1 1 1 1 0 0 0 1 1 1 0 0 0 0 1
0 0 1 1 1 1 0 0 0 0 0 0 1 1 1 1
0 0 0 1 1 1 1 0 0 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 0 0 0 0 1 1
U 012301213210321
0 1 1 1 1 0 0 0 0 0 0 0 1 1 1 1
0 0 1 1 1 1 0 0 1 1 1 0 0 0 0 1
0 0 0 1 1 1 1 0 0 0 1 1 1 1 0 0
0 0 0 0 1 1 1 1 1 0 0 0 0 1 1 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;that is, underneath each code it will include its representation in
matrix format.&lt;/p&gt;
&lt;p&gt;In his penultimate novella, "Westward Ho", Samuel Beckett wrote what
may be his most famous phrase:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ever tried. Ever failed. No matter. Try again. Fail again. Fail
better.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Notes&lt;/h2&gt;
&lt;p&gt;Our description of Gray codes follows &lt;a href='#knuth:2011' id='ref-knuth:2011-1'&gt;[2]&lt;/a&gt;, section 7.2.1.1.
Gray codes were named after Frank Gray, a physist that invented
&lt;span class="math"&gt;\(\Gamma_n\)&lt;/span&gt; for the analog transmission of digital signals; however
Gray codes existed before that. Knuth trafces them back to 1878, when
&lt;span class="math"&gt;\(\Gamma_5\)&lt;/span&gt; were used by \'{E}mile Baudot in a telegraph machine. The
term "baud", named after him, is a unit of transmission equalling the
number of times a signal changes per second. Knuth also points out
that Gray codes underlie the
&lt;a href="https://en.wikipedia.org/wiki/Baguenaudier"&gt;Baguenaudier&lt;/a&gt; or Chinese
ring puzzle. The algorithm we present here is adapted from
&lt;a href='#sawada:2007' id='ref-sawada:2007-1'&gt;[3]&lt;/a&gt;; see &lt;a href='#cooke:2016' id='ref-cooke:2016-1'&gt;[1]&lt;/a&gt; for a more recent development.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;hr&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;div class='bibliography'&gt;&lt;ol&gt;&lt;li id='cooke:2016'&gt;Mark Cooke, Chris North, Megan Dewar, and Brett Stevens.
A note on &lt;span class="bibtex-protected"&gt;B&lt;/span&gt;eckett-&lt;span class="bibtex-protected"&gt;G&lt;/span&gt;ray codes and the relationship of &lt;span class="bibtex-protected"&gt;G&lt;/span&gt;ray codes to data structures.
2016.
URL: &lt;a href="https://arxiv.org/abs/1608.06001"&gt;https://arxiv.org/abs/1608.06001&lt;/a&gt;, &lt;a href="https://doi.org/10.48550/ARXIV.1608.06001"&gt;doi:10.48550/ARXIV.1608.06001&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-cooke:2016-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='knuth:2011'&gt;Donald&amp;nbsp;E. Knuth.
&lt;em&gt;The Art of Computer Programming, Volume &lt;span class="bibtex-protected"&gt;4A&lt;/span&gt;: Combinatorial Algorithms, Part 1&lt;/em&gt;.
Addison-Wesley, Upper Saddle River, NJ, 2011. &lt;a class="cite-backref" href="#ref-knuth:2011-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='sawada:2007'&gt;Joe Sawada and Dennis&amp;nbsp;Chi-Him Wong.
A fast algorithm to generate &lt;span class="bibtex-protected"&gt;B&lt;/span&gt;eckett-&lt;span class="bibtex-protected"&gt;G&lt;/span&gt;ray codes.
&lt;em&gt;Electronic Notes in Discrete Mathematics&lt;/em&gt;, 29:571–577, 2007.
European Conference on Combinatorics, Graph Theory and Applications. &lt;a class="cite-backref" href="#ref-sawada:2007-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><category term="assignments"></category></entry><entry><title>Covering Points</title><link href="https://louridas.github.io/assignments/covering-points/" rel="alternate"></link><published>2022-05-19T00:00:00+03:00</published><updated>2022-05-19T00:00:00+03:00</updated><author><name>Panos Louridas</name></author><id>tag:louridas.github.io,2022-05-19:/assignments/covering-points/</id><summary type="html">&lt;p&gt;Imagine that you have a set of points on a plane and you want to cover
them with a set of straight lines. Can you find the mininum number of
straight lines passing through the points so that you cover all of
them?&lt;/p&gt;
&lt;p&gt;This is the so-called &lt;em&gt;hitting objects&lt;/em&gt;, or …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Imagine that you have a set of points on a plane and you want to cover
them with a set of straight lines. Can you find the mininum number of
straight lines passing through the points so that you cover all of
them?&lt;/p&gt;
&lt;p&gt;This is the so-called &lt;em&gt;hitting objects&lt;/em&gt;, or &lt;em&gt;point cover&lt;/em&gt;, or &lt;em&gt;line
cover&lt;/em&gt;, or &lt;em&gt;point line cover&lt;/em&gt; problem. The first name comes from the
analogy of a set of objects that we want to hit with the minimum
number of shots. Of course, the problem is more general than just an
application of ballistics or optimizing a bombing campaign. You may
need to find the minimum number of straight segments that lie on a
number of facilities on the plain, such as irrigation channels
connecting reservoirs. Be it as it may, this assignment is titled
"Covering Points", instead of "Hitting Objects", to defuse any
trigger-happy connotation.&lt;/p&gt;
&lt;p&gt;For example, see the following figure, which shows 18 points. &lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/covering-points/hitting_objects_1.png" width="700"/&gt;&lt;/p&gt;
&lt;p&gt;We can cover these points using five lines, like this:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/covering-points/hitting_objects_2.png" width="700"/&gt;&lt;/p&gt;
&lt;p&gt;Alternatively, if we have the additional requirement that the lines
should be horizontal or vertical, then the optimum solution uses six
lines:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/covering-points/hitting_objects_3.png" width="700"/&gt;&lt;/p&gt;
&lt;p&gt;The question is, how do we go about finding these solutions?&lt;/p&gt;
&lt;h2&gt;Solution Method&lt;/h2&gt;
&lt;p&gt;Selecting the minimum number of lines passing through a set of points
is a geometric version of the more general &lt;em&gt;set covering problem&lt;/em&gt;.
This is defined as follows: If we have a set of elements, which we
call &lt;em&gt;universe&lt;/em&gt;, &lt;span class="math"&gt;\(U = \{1, 2, \ldots n\}\)&lt;/span&gt;, and a set &lt;span class="math"&gt;\(S\)&lt;/span&gt; of &lt;span class="math"&gt;\(m\)&lt;/span&gt; sets
whose union equals the universe, find the smallest subset of &lt;span class="math"&gt;\(S\)&lt;/span&gt; whose
union equals the universe. The set covering problem is equivalent to
the points covering problem if we take &lt;span class="math"&gt;\(U\)&lt;/span&gt; to be the set of points
that we want to cover and &lt;span class="math"&gt;\(S\)&lt;/span&gt; the set of lines passing through the
points (each line defined by the points it goes through).&lt;/p&gt;
&lt;p&gt;For example, let's have as universe &lt;span class="math"&gt;\(U = \{1, 2, 3, 4, 5\}\)&lt;/span&gt; and the
set of sets &lt;span class="math"&gt;\(S = \{\{1\}, \{1, 2\}, \{1, 2, 3\}, \{2, 4\}, \{3, 4\},
\{4, 5\}\}\)&lt;/span&gt;. We can see that the union of all members of &lt;span class="math"&gt;\(S\)&lt;/span&gt; gives us
&lt;span class="math"&gt;\(U\)&lt;/span&gt;, but we can also cover &lt;span class="math"&gt;\(U\)&lt;/span&gt; using the &lt;span class="math"&gt;\(\{\{1, 2, 3\}, \{4, 5\}\}\)&lt;/span&gt;
subset of &lt;span class="math"&gt;\(S\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Unfortunately, the set covering problem cannot be solved in polynomial
time. Indeed, take this approach:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For every possible subset of &lt;span class="math"&gt;\(S\)&lt;/span&gt;:&lt;ul&gt;
&lt;li&gt;Check if it covers &lt;span class="math"&gt;\(U\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;If yes, and it is smaller than the best candidate solution that we
  have found so far, note it as the best candidate solution.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When these steps finish, the final candidate solution will also be the
best. The problem lies in the phrase "for every possible subset of
&lt;span class="math"&gt;\(S\)&lt;/span&gt;". If a set contains &lt;span class="math"&gt;\(m\)&lt;/span&gt; elements, the number of possible subsets
is &lt;span class="math"&gt;\(2^m\)&lt;/span&gt;; therefore, unless &lt;span class="math"&gt;\(m\)&lt;/span&gt; is small, there is no way we can find
the solution in a reasonable amount of time. &lt;/p&gt;
&lt;p&gt;Of course, if you think about it, you do not need to check every
possible subset of &lt;span class="math"&gt;\(S\)&lt;/span&gt;. As we want the minimum number of elements, or
to be more specific, lines, we can improve our approach:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Enumerate the subsets of &lt;span class="math"&gt;\(S\)&lt;/span&gt; in increasing size (number of lines):&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check if the current subset covers &lt;span class="math"&gt;\(U\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If yes, that is the solution we are looking for and we can stop.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This will give us the best solution. If we go on without stopping, we
may find another solution with the same number of lines, which won't
improve on what we have already found, or with a larger number of
lines, which we don't want.&lt;/p&gt;
&lt;p&gt;The problem remains that even this improved approach will not
necessarily run in a reasonable amount of time. The points that we
want to cover may be placed in way that only pairs of them are
colinear. Then, if we have &lt;span class="math"&gt;\(n\)&lt;/span&gt; points, we need &lt;span class="math"&gt;\(n/2\)&lt;/span&gt; lines to cover
them, but we don't know that beforehand. We will start checking with
the smallest number of lines and then go on increasing the number of
lines until we get to the required &lt;span class="math"&gt;\(n/2\)&lt;/span&gt; lines:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Subsets with zero lines (the empty subset).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Subsets containing only one line (these will cover only two points
  each).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Subsets containing two lines (these will cover only four points
  each).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;And so and so forth, until we arrive at a subset containing &lt;span class="math"&gt;\(n/2\)&lt;/span&gt;
  lines. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, in the end, we will still need to check an exponential number of
subsets, of the order of &lt;span class="math"&gt;\(2^{n/2}\)&lt;/span&gt;. Now, you may observe that we don't
need to check subsets with zero lines or one line, but that is just a
drop in the ocean of possible solutions that we have to check. If you
want to see an example of points that are only pairwise colinear,
check the &lt;a href="https://en.wikipedia.org/wiki/No-three-in-line_problem"&gt;No-three-in-line problem&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Alternatively, we can use a different approach, which will complete
fast, but it is not guaranteed to come up with the best solution:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Start with a new, empty solution.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;While not all elements of &lt;span class="math"&gt;\(U\)&lt;/span&gt; have been covered:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find the member of &lt;span class="math"&gt;\(S\)&lt;/span&gt; that covers the greatest number of
  uncovered elements and add them to the solution.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This approach is a &lt;em&gt;greedy algorithm&lt;/em&gt;, because at each step in the
iteration it proceeds by opting for the maximum immediate payoff (the
maximum number of elements that can be covered at that point). But
this does not ensure that at the end we will have the best solution
overall. As we know, delayed gratification has something going for it,
and a greedy algorithm may have to pay a price in the long run. If we
return to the example with the points and the lines that run
horizontally or vertically, a greedy algorithm could finish with the
following solution, instead of the best one:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/covering-points/hitting_objects_4.png" width="700"/&gt;&lt;/p&gt;
&lt;p&gt;How can this happen? The greedy algorithm may select the vertical line
that cuts the horizontal axis at 11, then the vertical line that cuts
the horizontal axis at 10, and so on, adding vertical lines to the
solution until it reaches 7 on the horizontal axis. Then it will have
to cover the remaining points with abscissae 1 to 6 by adding
horizontal lines to the solution.&lt;/p&gt;
&lt;h2&gt;Requirements&lt;/h2&gt;
&lt;p&gt;You will write a program called &lt;code&gt;points_cover.py&lt;/code&gt;. You may use the
following libraries:
&lt;a href="https://docs.python.org/3/library/itertools.html"&gt;&lt;code&gt;itertools&lt;/code&gt;&lt;/a&gt;,
&lt;a href="https://docs.python.org/3/library/argparse.html"&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; or
&lt;a href="https://docs.python.org/3/library/sys.html"&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; (in particular,
the list &lt;code&gt;sys.argv&lt;/code&gt;) to handle program arguments.&lt;/p&gt;
&lt;p&gt;Your program will be called as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python points_cover.py &lt;span class="o"&gt;[&lt;/span&gt;-f&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-g&lt;span class="o"&gt;]&lt;/span&gt; points_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The meaning of the program arguments is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The argument&lt;code&gt;-f&lt;/code&gt; (full exploration), if given, instructs the program
  to find the best solution, examining as many subsets as needed. If
  the problem is small, that is, there are few lines, the program
  should finish relatively fast. If the problem is not small then the
  program may take, literally, ages to finish, but that is not your
  problem. If the argument &lt;code&gt;-f&lt;/code&gt; is not given, the program will execute
  the greedy algorithm.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The argument &lt;code&gt;-g&lt;/code&gt; (grid), if given, instructs the program to find
  only lines that are horizontal or vertical. If it is not given, the
  program may use any lines that pass through the points.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The argument &lt;code&gt;points_file&lt;/code&gt; is the name of the file that contains the
  points we want to cover. The file consists of lines of the form:&lt;br/&gt;
   &lt;code&gt;text
    x y&lt;/code&gt;
    &lt;br/&gt;
  where &lt;code&gt;x&lt;/code&gt; is the &lt;span class="math"&gt;\(x\)&lt;/span&gt;-axis coordinate and &lt;code&gt;y&lt;/code&gt; is the &lt;span class="math"&gt;\(y\)&lt;/span&gt;-axis
  coordinate of each point.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we specify &lt;code&gt;-g&lt;/code&gt; and it is not possible to cover all points with
lines passing through at least two of them, you may use horizontal
lines that pass through the points that are not colinear with another
point in the horizontal or vertical direction. So, if there is a point
&lt;span class="math"&gt;\((x, y)\)&lt;/span&gt; and there is no point &lt;span class="math"&gt;\((x', y)\)&lt;/span&gt; or &lt;span class="math"&gt;\((x, y')\)&lt;/span&gt;, you can use the
line passing through &lt;span class="math"&gt;\(((x, y), (x + 1, y))\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The lines that will make up your solutions must appear in descending
order based on the number of points they cover. In other words, lines
covering more points will precede lines covering fewer points. For
each line, the point it covers will appear in ascending order, based
on their coordinates. Lines covering the same number of points will
appear in ascending order, depending on the coordinates of their
points.&lt;/p&gt;
&lt;p&gt;Depending on your implementation, you may need to sort the input
points you read from &lt;code&gt;points_file&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Examples&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Example 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python points_cover.py example_1.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then the program will read the file 
&lt;a href="https://louridas.github.io/rwa/assignments/covering-points/example_1.txt"&gt;&lt;code&gt;example_1.txt&lt;/code&gt;&lt;/a&gt;
and will display the following results:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(1, 1) (2, 2) (3, 3) (4, 4) (5, 5) (6, 6)
(7, 1) (8, 3) (9, 5)
(7, 2) (8, 4) (9, 6)
(10, 1) (10, 2) (10, 3)
(11, 4) (11, 5) (11, 6)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is the first solution we saw for covering the 18 points given in
the beginning of this assignment.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python points_cover.py -f -g example_1.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then the program will read the file 
&lt;a href="https://louridas.github.io/rwa/assignments/covering-points/example_1.txt"&gt;&lt;code&gt;example_1.txt&lt;/code&gt;&lt;/a&gt;
and will display the following results:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(1, 1) (7, 1) (10, 1)
(2, 2) (7, 2) (10, 2)
(3, 3) (8, 3) (10, 3)
(4, 4) (8, 4) (11, 4)
(5, 5) (9, 5) (11, 5)
(6, 6) (9, 6) (11, 6)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is the second solution we saw for covering the 18 points given in
the beginning of this assignment.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python points_cover.py -g example_2.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then the program will read the file 
&lt;a href="https://louridas.github.io/rwa/assignments/covering-points/example_2.txt"&gt;&lt;code&gt;example_2.txt&lt;/code&gt;&lt;/a&gt;
and will display the following results:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(10, 1) (10, 2) (10, 3)
(11, 4) (11, 5) (11, 6)
(12, 7) (12, 8) (12, 9)
(1, 1) (10, 1)
(2, 2) (10, 2)
(3, 3) (10, 3)
(4, 4) (11, 4)
(5, 5) (11, 5)
(6, 6) (11, 6)
(7, 7) (12, 7)
(8, 8) (12, 8)
(9, 9) (12, 9)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/covering-points/hitting_objects_5.png" width="700"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python points_cover.py -f -g example_2.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then the program will read the file 
&lt;a href="https://louridas.github.io/rwa/assignments/covering-points/example_2.txt"&gt;&lt;code&gt;example_2.txt&lt;/code&gt;&lt;/a&gt;
and will display the following results:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(1, 1) (10, 1)
(2, 2) (10, 2)
(3, 3) (10, 3)
(4, 4) (11, 4)
(5, 5) (11, 5)
(6, 6) (11, 6)
(7, 7) (12, 7)
(8, 8) (12, 8)
(9, 9) (12, 9)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/covering-points/hitting_objects_6.png" width="700"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 5&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python points_cover.py -g example_3.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then the program will read the file
&lt;a href="https://louridas.github.io/rwa/assignments/covering-points/example_3.txt"&gt;&lt;code&gt;example_3.txt&lt;/code&gt;&lt;/a&gt;
and will display the following results:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(10, 1) (10, 2) (10, 3)
(11, 4) (11, 5) (11, 6)
(1, 1) (10, 1)
(2, 2) (10, 2)
(3, 3) (10, 3)
(4, 4) (11, 4)
(5, 5) (11, 5)
(6, 6) (11, 6)
(7, 7) (8, 7)
(8, 8) (9, 8)
(9, 9) (10, 9)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/covering-points/hitting_objects_7.png" width="700"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 6&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python points_cover.py -f -g example_3.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then the program will read the file
&lt;a href="https://louridas.github.io/rwa/assignments/covering-points/example_3.txt"&gt;&lt;code&gt;example_3.txt&lt;/code&gt;&lt;/a&gt;
and will display the following results:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(1, 1) (10, 1)
(2, 2) (10, 2)
(3, 3) (10, 3)
(4, 4) (11, 4)
(5, 5) (11, 5)
(6, 6) (11, 6)
(7, 7) (8, 7)
(8, 8) (9, 8)
(9, 9) (10, 9)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/covering-points/hitting_objects_8.png" width="700"/&gt;&lt;/p&gt;
&lt;h2&gt;Notes&lt;/h2&gt;
&lt;p&gt;For the formulation of the problem as one of locating linear
facilities on the plane see &lt;a href='#megiddo:1981' id='ref-megiddo:1981-1'&gt;[4]&lt;/a&gt;; for its hitting objects
incarnation, see &lt;a href='#hassin:1991' id='ref-hassin:1991-1'&gt;[1]&lt;/a&gt;. A more generic treatment is to view
it as covering things with things &lt;a href='#langerman:2005' id='ref-langerman:2005-1'&gt;[3]&lt;/a&gt;. To be precise,
according to &lt;a href='#megiddo:1981' id='ref-megiddo:1981-2'&gt;[4]&lt;/a&gt; the point covering problem is the one we
treated here; the line covering problem consists of starting with a
set of straight lines and finind a minimum set of points such as each
line contains at least one of them. The two problems are closely
related and line covering can be reduced, i.e., recast, as point
covering. For some more recent results, see &lt;a href='#kratsch:2016' id='ref-kratsch:2016-1'&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;hr&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;div class='bibliography'&gt;&lt;ol&gt;&lt;li id='hassin:1991'&gt;Refael Hassin and Nimrod Megiddo.
Approximation algorithms for hitting objects with straight lines.
&lt;em&gt;Discrete Applied Mathematics&lt;/em&gt;, 30(1):29–42, January 1991.
URL: &lt;a href="https://doi.org/10.1016/0166-218X(91)90011-K"&gt;https://doi.org/10.1016/0166-218X(91)90011-K&lt;/a&gt;, &lt;a href="https://doi.org/10.1016/0166-218X(91)90011-K"&gt;doi:10.1016/0166-218X(91)90011-K&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-hassin:1991-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='kratsch:2016'&gt;Stefan Kratsch, Geevarghese Philip, and Saurabh Ray.
Point line cover: the easy kernel is essentially tight.
&lt;em&gt;ACM Transactions on Algorithms&lt;/em&gt;, April 2016.
URL: &lt;a href="https://doi.org/10.1145/2832912"&gt;https://doi.org/10.1145/2832912&lt;/a&gt;, &lt;a href="https://doi.org/10.1145/2832912"&gt;doi:10.1145/2832912&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-kratsch:2016-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='langerman:2005'&gt;Stefan Langerman and Pat Morin.
Covering things with things.
&lt;em&gt;Discrete Computational Geometry&lt;/em&gt;, 33(4):717–729, April 2005. &lt;a class="cite-backref" href="#ref-langerman:2005-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='megiddo:1981'&gt;Nimrod Megiddo and Arie Tamir.
On the complexity of locating linear facilities in the plane.
&lt;em&gt;Operations Research Letters&lt;/em&gt;, 194–197 1981.&lt;a class="cite-backref" href="#ref-megiddo:1981-1" title="Jump back to reference 1"&gt; &lt;sup&gt;1&lt;/sup&gt; &lt;/a&gt;&lt;a class="cite-backref" href="#ref-megiddo:1981-2" title="Jump back to reference 2"&gt;&lt;sup&gt;2&lt;/sup&gt; &lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><category term="assignments"></category></entry><entry><title>Regular Crosswords</title><link href="https://louridas.github.io/assignments/regular-crosswords/" rel="alternate"></link><published>2022-05-18T00:00:00+03:00</published><updated>2022-05-18T00:00:00+03:00</updated><author><name>Panos Louridas</name></author><id>tag:louridas.github.io,2022-05-18:/assignments/regular-crosswords/</id><summary type="html">&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/regular-crosswords/alex_bellos.png" width="600"/&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
    &lt;td&gt;L(OL)+&lt;/td&gt;
    &lt;td&gt;(HO)+&lt;/td&gt;
    &lt;td&gt;K(EK)*E&lt;/td&gt;
    &lt;td&gt;(HAR)+)+&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;H(EH)+&lt;/td&gt;
    &lt;td&gt;ROT?FL&lt;/td&gt;
    &lt;td&gt;TE(HE+)+&lt;/td&gt;
    &lt;td&gt;LAW*L&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;MWA(HA)+&lt;/td&gt;
    &lt;td&gt;HE(HE)+&lt;/td&gt;
    &lt;td&gt;LO+L&lt;/td&gt;
    &lt;td&gt;HAHA*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;(AH)+A+&lt;/td&gt;
    &lt;td&gt;HA+&lt;/td&gt;
    &lt;td&gt;(JA)+&lt;/td&gt;
    &lt;td&gt;LULZ&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;In this assignment you will write a program to solve crosswords, like
the crossword above, created by Alex Bellos &lt;a href='#bellos:2020' id='ref-bellos:2020-1'&gt;[1]&lt;/a&gt;. But the
crossword …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/regular-crosswords/alex_bellos.png" width="600"/&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
    &lt;td&gt;L(OL)+&lt;/td&gt;
    &lt;td&gt;(HO)+&lt;/td&gt;
    &lt;td&gt;K(EK)*E&lt;/td&gt;
    &lt;td&gt;(HAR)+)+&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;H(EH)+&lt;/td&gt;
    &lt;td&gt;ROT?FL&lt;/td&gt;
    &lt;td&gt;TE(HE+)+&lt;/td&gt;
    &lt;td&gt;LAW*L&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;MWA(HA)+&lt;/td&gt;
    &lt;td&gt;HE(HE)+&lt;/td&gt;
    &lt;td&gt;LO+L&lt;/td&gt;
    &lt;td&gt;HAHA*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;(AH)+A+&lt;/td&gt;
    &lt;td&gt;HA+&lt;/td&gt;
    &lt;td&gt;(JA)+&lt;/td&gt;
    &lt;td&gt;LULZ&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;In this assignment you will write a program to solve crosswords, like
the crossword above, created by Alex Bellos &lt;a href='#bellos:2020' id='ref-bellos:2020-1'&gt;[1]&lt;/a&gt;. But the
crossword entries, given in the table, look strange. Indeed, our
crosswords will be different from traditional crosswords in the entry
definitions: they will be given with &lt;em&gt;regular expressions&lt;/em&gt;, or
&lt;em&gt;regexes&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Regular Expressions&lt;/h2&gt;
&lt;p&gt;Regular expressions are sequences of characters that describe strings.
We use regular expressions when we want to describe a string following
a pattern, instead of a particular string.&lt;/p&gt;
&lt;p&gt;For example, if somebody asks you to locate a certain phone number in
a file, you will try to match the given phone number with the contents
of the file. But what if somebody asks to to find all phone numbers in
a file? Similarly, if somebody asks you to find a particular e-mail
address inside a file, you can simply search for it in the file. But
what if you need to find all e-mail addresses that are present in the
file? Or, you may want to find a word, taking into account different
variants of it (or mispellings); say you want to find "neighbor" and
"neighbour". &lt;/p&gt;
&lt;p&gt;With regular expressions we use characters taken from the alphabet
and some other, special characters, in order to describe the strings
that we looking for. So:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The special character &lt;code&gt;*&lt;/code&gt; means that the preceding item may appear
  zero or more times. The regular expression &lt;code&gt;ca*t&lt;/code&gt; describes the
  strings &lt;code&gt;ct&lt;/code&gt;, &lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;caat&lt;/code&gt;, etc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The special character &lt;code&gt;+&lt;/code&gt; means that the preceding item may appear
  one or more times. The regular expression &lt;code&gt;ca+t&lt;/code&gt; describes the
  strings &lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;caat&lt;/code&gt;, &lt;code&gt;caaat&lt;/code&gt;, etc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The special character &lt;code&gt;?&lt;/code&gt; means that the preceding item may appear
  zero or one time. The regular expression &lt;code&gt;ca?t&lt;/code&gt; describes the
  strings &lt;code&gt;ct&lt;/code&gt; and &lt;code&gt;cat&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An item can be a single character, as in our examples, or a group of
characters enclosed in brackets. The regular expression &lt;code&gt;(ba)+boom&lt;/code&gt;
describes the strings &lt;code&gt;baboom&lt;/code&gt;, &lt;code&gt;bababoom&lt;/code&gt;, &lt;code&gt;babababoom&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;Knowing regular expressions, you can solve the crossword at the
beginning of this assignment, expanding the regular expressions given
under the crossword as needed to cover all squares.&lt;/p&gt;
&lt;h2&gt;Solution Method&lt;/h2&gt;
&lt;p&gt;To solve the crossword, we must use an algorithm that tries all
possible regular expressions until all squares are filled. We cannot
do that in random, as it is infeasible to try all possible strings
that are produced by the regular expressions given. We must adopt a
somewhat more systematic approach, like the one below.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;While there are still entries that have not been filled:&lt;/li&gt;
  &lt;ol start="2"&gt;
    &lt;li&gt;Pick an entry that has not been filled.&lt;/li&gt;
    &lt;li&gt;Find the regular expressions that can fill the squares of the
        selected entry.&lt;/li&gt;
    &lt;li&gt;For each one of these candidate regular expressions, fill the
        squares of the selected entry and continue recursively from
        step 1.
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/ol&gt;

&lt;h2&gt;Requirements&lt;/h2&gt;
&lt;p&gt;You will write a program called &lt;code&gt;re_crossword.py&lt;/code&gt;. You may use the
libraries: &lt;a href="https://docs.python.org/3/library/string.html"&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;,
&lt;a href="https://docs.python.org/3/library/re.html"&gt;&lt;code&gt;re&lt;/code&gt;&lt;/a&gt;,
&lt;a href="https://github.com/google/sre_yield"&gt;&lt;code&gt;sre_yield&lt;/code&gt;&lt;/a&gt;,
&lt;a href="https://docs.python.org/3/library/csv.html"&gt;&lt;code&gt;csv&lt;/code&gt;&lt;/a&gt;,
&lt;a href="https://docs.python.org/3/library/argparse.html"&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; or
&lt;a href="https://docs.python.org/3/library/sys.html"&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; (in particular,
the list &lt;code&gt;sys.argv&lt;/code&gt;) to handle program arguments.&lt;/p&gt;
&lt;p&gt;To solve the crossword you must start with the regular expressions
that you can use to generate the strings that will fill the entries.
To generate the strings you will use the &lt;code&gt;sre_yield&lt;/code&gt; library. This
library provides the function  &lt;code&gt;sre_yield.AllStrings(pattern)&lt;/code&gt; that
generates all the strings that correspond to the regular expression 
&lt;code&gt;pattern&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;Your program will be called as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python re_crossword.py crossword_file regular_expressions_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The meaning of the program arguments is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;crossword_file&lt;/code&gt;: the file that contains the crossword description. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;regular_expressions_file&lt;/code&gt;: the file that contains the regular
  expressions that you will use on the crossword. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The format of &lt;code&gt;crossword_file&lt;/code&gt; will be CSV (Comma Separated Values).
Each line will contain the following fields, which will be separated
by commas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Crossword entry.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;String representing the entry concents. Every unknown character is
   represented with a period (&lt;code&gt;.&lt;/code&gt;). &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;One or more number pairs. The first number in a pair corresponds to
   the entry intersecting the current entry. The second number in each
   pair corresponds to the position of the intersecting character in
   the intersecting entry. &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For example, the first line of &lt;a href="https://louridas.github.io/rwa/assignments/regular-crosswords/laughs.csv"&gt;&lt;code&gt;laughs.csv&lt;/code&gt;&lt;/a&gt;
describes entry 0 of the crossword:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0,......,15,0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The entry has six unknown characters (&lt;code&gt;......&lt;/code&gt;) and intersects entry 15
at position 0.&lt;/p&gt;
&lt;p&gt;The last but one line of the same file describes entry 13 of the
crossword:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;13,........,4,4,10,3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The entry has eight unknown characters (&lt;code&gt;........&lt;/code&gt;) and intersects
entry 4 at position 4 and entry 10 at position 3.&lt;/p&gt;
&lt;p&gt;The entries will be numbered sequentially. Horizontal entries will be
even-numbered and vertical entries will be odd-numbered, as you can
see in the crossword at the start. If a square is the initial
character of two entries, in the displayed crossword the square will
be labelled with both of them, as happens with the square labelled
2/1.&lt;/p&gt;
&lt;p&gt;The program output will be a sequence of lines of the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;X regex word
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;where &lt;code&gt;Χ&lt;/code&gt; is the number of the entry, &lt;code&gt;regex&lt;/code&gt; is the regular
expression that fits, and &lt;code&gt;word&lt;/code&gt; is the result of expanding the
regular expression so that the entry is filled. The output lines will
be sorted in ascending order by the entry number.&lt;/p&gt;
&lt;h3&gt;Implementation Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In step 2 of the algorithm that you will develop you must choose an
  entry that has not been filled yet. Choosing the right entry can
  have a very large impact on the number of steps that will be carried
  out and the overall speed of your program. A sensible strategy is to
  choose the entry with the greatest ratio of known letters over the
  entry lenght.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The function &lt;code&gt;sre_yield.AllStrings(pattern)&lt;/code&gt; can, depending on the
  regular expression, return a very large number of strings. To keep
  this number in check we can use the parameter &lt;code&gt;max_count&lt;/code&gt;. For the
  purposes of this assignment, &lt;code&gt;max_count=5&lt;/code&gt;, that is,
  &lt;code&gt;sre_yield.AllStrings(pattern, max_count=5)&lt;/code&gt;, should be enough.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the regular expression contains the special character &lt;code&gt;.&lt;/code&gt;, then
  the &lt;code&gt;sre_yield.AllStrings(pattern)&lt;/code&gt; functions will try all possible
  characters at that position. In our crosswords, however, we will
  only use upper case latin characters. To avoid trying characters
  that will never occur in the crossword, you should use the parameter
  &lt;code&gt;charset&lt;/code&gt;, giving &lt;code&gt;charset=string.ascii_uppercase&lt;/code&gt;. Together with
  the previous point, the call should be
  &lt;code&gt;sre_yield.AllStrings(pattern, max_count=5,
  charset=string.ascii_uppercase)&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;sre_yield.AllStrings(pattern)&lt;/code&gt; function may return the same
  string more than once, so you must ensure that you use each string
  once only.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Examples&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Example 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python re_crossword.py laughs.csv laughs.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then the program will read the file
&lt;a href="https://louridas.github.io/rwa/assignments/regular-crosswords/laughs.csv"&gt;&lt;code&gt;laughs.csv&lt;/code&gt;&lt;/a&gt;,
which describes the crossword at the start of this assignment, and the
file
&lt;a href="https://louridas.github.io/rwa/assignments/regular-crosswords/laughs.txt"&gt;&lt;code&gt;laughs.txt&lt;/code&gt;&lt;/a&gt;,
which describes the regular expressions. It will display the following
results:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0 HAHA* HAHAAA
1 HE(HE)+ HEHEHE
2 (HO)+ HOHO
3 HA+ HAA
4 TE(HE+)+ TEHEHEHE
5 LO+L LOOL
6 L(OL)+ LOLOLOL
7 LULZ LULZ
8 K(EK)*E KEKE
9 ROT?FL ROTFL
10 MWA(HA)+ MWAHA
11 LAW*L LAWL
12 H(EH)+ HEH
13 (HAR+)+ HARRHARR
14 (JA)+ JAJAJAJAJA
15 (AH)+A+ AHAHA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Example 2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/regular-crosswords/films.png" width="600"/&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python re_crossword.py films.csv films.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then the program will read the file 
&lt;a href="https://louridas.github.io/rwa/assignments/regular-crosswords/films.csv"&gt;&lt;code&gt;films.csv&lt;/code&gt;&lt;/a&gt;, 
which describes the crossword, and the file
&lt;a href="https://louridas.github.io/rwa/assignments/regular-crosswords/films.txt"&gt;&lt;code&gt;films.txt&lt;/code&gt;&lt;/a&gt;,
which describes the regular expressions, and will show the following output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0 (M?ON)+CLE MONONCLE
1 SIDEWAYS SIDEWAYS
2 (((OU)|(GE))T)+ GETOUT
3 MO+D([FL]O[RV])+E MOODFORLOVE
4 (MAD?)+X MADMAX
5 ([BM]A[NT])+ BATMAN
6 S([TW]AR)+S STARWARS
7 SH(IN)+G SHINING
8 ([BL](AN?D))+S BADLANDS
9 S((EN)|(EV))+ SEVEN
10 S((EN)|(EV))+THSEAL SEVENTHSEAL
11 CA((S|BL|NC)A)+ CASABLANCA
12 ([CG]A[LR]I)+ CALIGARI
13 ([KB](ILL))+ KILLBILL
14 (SHA[WN])+K SHAWSHANK
15 (K[IO]NG)+ KINGKONG
16 (S?TOR?Y)+ TOYSTORY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Example 3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Our crosswords may be a bit unconventional, if we allow each entry
position to intersect with &lt;em&gt;two&lt;/em&gt; others, so instead of squares we will
have hexagons, as in the following:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/regular-crosswords/hex.png" width="200"/&gt;&lt;/p&gt;
&lt;p&gt;In this crossword we do not have only across and down entries, we have
a dimension &lt;span class="math"&gt;\(x\)&lt;/span&gt;, whose values are the numbers whose modulo with 3 is
0, a dimension &lt;span class="math"&gt;\(y\)&lt;/span&gt;, whose values are the numbers whose modulo with 3
is 1, and a dimension &lt;span class="math"&gt;\(z\)&lt;/span&gt;, whose modulo with 3 is 2. If that seems
strange to you, note that this is the same rule we used previously,
where the entries were numbered modulo 2.&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python re_crossword.py hex.csv hex.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then the program will read the crossword description file 
&lt;a href="https://louridas.github.io/rwa/assignments/regular-crosswords/hex.csv"&gt;&lt;code&gt;hex.csv&lt;/code&gt;&lt;/a&gt;
and the regular expressions file
&lt;a href="https://louridas.github.io/rwa/assignments/regular-crosswords/hex.txt"&gt;&lt;code&gt;hex.txt&lt;/code&gt;&lt;/a&gt;
and should produce the following output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0 HE|HA|OH HE
1 NP|HX|SP HX
2 FN|EG|GN EG
3 .?[SAX][GAS].? XAG
4 .?[FAT][HOT].? EAO
5 .?[AND][NOT].? HAN
6 NO|ON|AT ON
7 XO|GN|PO GN
8 RO|GN|XO XO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Notes&lt;/h2&gt;
&lt;p&gt;It is possible that more than one solution exists for a given
crossword; if your program produces a different answer than the ones
above but still fills all the entries, it is of course correct. &lt;/p&gt;
&lt;p&gt;Regular expressions were introduced in the 1950s by the American
mathematician Stephen Cole Kleene &lt;a href='#kleene:1951' id='ref-kleene:1951-1'&gt;[3]&lt;/a&gt;. Their widespread
adoption in Computer Science began in 1968 when they were used for
searching in a text editor &lt;a href='#thompson:1968' id='ref-thompson:1968-1'&gt;[4]&lt;/a&gt; and lexical analysis in a
compiler &lt;a href='#johnson:1968' id='ref-johnson:1968-1'&gt;[2]&lt;/a&gt;. Regular expressions then became part of many
tools available in the Unix operating system.&lt;/p&gt;
&lt;p&gt;Regexes are a staple of data processing; there is plenty of material
available online to learn how to use them and the &lt;a href="https://en.wikipedia.org/wiki/Regular_expression"&gt;Wikipedia Regular
expression article&lt;/a&gt;
is a good place to start. It is extremely unlikely that you will not
benefit from getting acquainted with them, even if you only have to
process data sporadically.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;hr&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;div class='bibliography'&gt;&lt;ol&gt;&lt;li id='bellos:2020'&gt;Alex Bellos.
&lt;em&gt;The Language Lover's PuzzleBook: Lexical Perplexities and Cracking Conundrums from Across the Globe&lt;/em&gt;.
Guardian Faber Publishing, 2020. &lt;a class="cite-backref" href="#ref-bellos:2020-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='johnson:1968'&gt;Walter&amp;nbsp;L. Johnson, James&amp;nbsp;H. Porter, Stephanie&amp;nbsp;I. Ackley, and Douglas&amp;nbsp;T. Ross.
Automatic generation of efficient lexical processors using finite state techniques.
&lt;em&gt;Communications of the ACM&lt;/em&gt;, 11(12):805–813, December 1968.
URL: &lt;a href="https://doi.org/10.1145/364175.364185"&gt;https://doi.org/10.1145/364175.364185&lt;/a&gt;, &lt;a href="https://doi.org/10.1145/364175.364185"&gt;doi:10.1145/364175.364185&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-johnson:1968-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='kleene:1951'&gt;S.&amp;nbsp;C. Kleene.
Representation of events in nerve nets and finite automata.
U.S. Air Force Project RAND Research Memorandum RM-704, The RAND Corporation, Santa Monica, CA, 1951. &lt;a class="cite-backref" href="#ref-kleene:1951-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='thompson:1968'&gt;Ken Thompson.
Programming techniques: regular expression search algorithm.
&lt;em&gt;Communications of the ACM&lt;/em&gt;, 11(6):419–422, June 1968.
URL: &lt;a href="https://doi.org/10.1145/363347.363387"&gt;https://doi.org/10.1145/363347.363387&lt;/a&gt;, &lt;a href="https://doi.org/10.1145/363347.363387"&gt;doi:10.1145/363347.363387&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-thompson:1968-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><category term="assignments"></category></entry><entry><title>Four Russians</title><link href="https://louridas.github.io/assignments/four-russians/" rel="alternate"></link><published>2019-04-16T00:00:00+03:00</published><updated>2019-04-16T00:00:00+03:00</updated><author><name>Panos Louridas</name></author><id>tag:louridas.github.io,2019-04-16:/assignments/four-russians/</id><summary type="html">&lt;p&gt;We can carry out various calculations on matrices, like for instance
multiplying them. Apart from traditional matrix multiplication, we can
also define &lt;em&gt;boolean matrix multiplication&lt;/em&gt; when our matrices are
boolean, that is, when their elements are ones and zeros. To see what
exactly boolean matrix multiplication is, let us start …&lt;/p&gt;</summary><content type="html">&lt;p&gt;We can carry out various calculations on matrices, like for instance
multiplying them. Apart from traditional matrix multiplication, we can
also define &lt;em&gt;boolean matrix multiplication&lt;/em&gt; when our matrices are
boolean, that is, when their elements are ones and zeros. To see what
exactly boolean matrix multiplication is, let us start from plain
matrix multiplication.&lt;/p&gt;
&lt;p&gt;If we have a matrix &lt;span class="math"&gt;\(A\)&lt;/span&gt; with dimensions &lt;span class="math"&gt;\(n \times m\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$A ={\begin{pmatrix}a_{11} &amp;amp; a_{12}&amp;amp; \cdots &amp;amp;a_{1m}\\
a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2m} \\
\vdots &amp;amp;\vdots &amp;amp; \ddots &amp;amp;\vdots \\
a_{n1} &amp;amp; a_{n2}&amp;amp; \cdots &amp;amp;a_{nm}\\\end{pmatrix}}$$&lt;/div&gt;
&lt;p&gt;and a matrix &lt;span class="math"&gt;\(B\)&lt;/span&gt; with dimensions &lt;span class="math"&gt;\(m \times p\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$B ={\begin{pmatrix}b_{11} &amp;amp; b_{12} &amp;amp; \cdots &amp;amp; b_{1p}\\
b_{21} &amp;amp; b_{22} &amp;amp; \cdots &amp;amp;b_{2p}\\
\vdots &amp;amp;\vdots &amp;amp; \ddots &amp;amp;\vdots \\
b_{m1} &amp;amp; b_{m2} &amp;amp; \cdots &amp;amp;B_{mp}\\
\end{pmatrix}}$$&lt;/div&gt;
&lt;p&gt;then their product is matrix &lt;span class="math"&gt;\(C\)&lt;/span&gt;, with dimensions &lt;span class="math"&gt;\(n \times p\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$C ={\begin{pmatrix} c_{11} &amp;amp; c_{12} &amp;amp; \cdots &amp;amp; c_{1p}\\
c_{21} &amp;amp; c_{22} &amp;amp; \cdots &amp;amp; c_{2p}\\
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\
c_{n1} &amp;amp; c_{n2} &amp;amp; \cdots &amp;amp; c_{np}\\\end{pmatrix}}$$&lt;/div&gt;
&lt;p&gt;In this matrix, each element &lt;span class="math"&gt;\(c_{ij}\)&lt;/span&gt; is the result of the sum of the
products of every element of line &lt;span class="math"&gt;\(i\)&lt;/span&gt; with the corresponding element
of column &lt;span class="math"&gt;\(j\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$c_{ij}=\sum _{k=1}^{m}a_{ik}b_{kj}$$&lt;/div&gt;
&lt;p&gt;To perform the calculations for all elements of &lt;span class="math"&gt;\(C\)&lt;/span&gt; we need time
&lt;span class="math"&gt;\(O(n^3)\)&lt;/span&gt; if we apply the above formula.&lt;/p&gt;
&lt;p&gt;Now, if we have binary numbers, we can define boolean multiplication
as the following operation, which is equivalent to the &lt;a href="https://en.wikipedia.org/wiki/Logical_conjunction"&gt;logical AND
operation&lt;/a&gt;, also
called conjunction, whose symbol is &lt;span class="math"&gt;\(\wedge\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{align*}
1 \wedge 1 = 1 \times 1 = 1\\
1 \wedge 0 = 1 \times 0 = 0\\
0 \wedge 1 = 0 \times 1 = 0\\
0 \wedge 0 = 0 \times 0 = 0\\
\end{align*}
$$&lt;/div&gt;
&lt;p&gt;Along the same lines we can define boolean addition as the following
operation, equivalent to the &lt;a href="https://en.wikipedia.org/wiki/Logical_disjunction"&gt;logical OR
operation&lt;/a&gt;, also
called disjunction, whose symbol is &lt;span class="math"&gt;\(\vee\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{align*}
1 \vee 1 = 1 + 1 = 1\\
1 \vee 0 = 1 + 0 = 1\\
0 \vee 1 = 0 + 1 = 1\\
0 \vee 0 = 0 + 0 = 0\\
\end{align*}$$&lt;/div&gt;
&lt;p&gt;Once we have defined boolean multiplication and boolean addition, we
can define boolean matrix multiplication, where each element &lt;span class="math"&gt;\(c_{ij}\)&lt;/span&gt;
is defined as before, but using boolean operations:&lt;/p&gt;
&lt;div class="math"&gt;$$c_{ij}= \bigvee _{k=1}^{m}a_{ik} \wedge b_{kj}$$&lt;/div&gt;
&lt;p&gt;For example, if we have&lt;/p&gt;
&lt;div class="math"&gt;$$A ={\begin{bmatrix} 
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\
1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\
1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 \\
1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp;  1\\
\end{bmatrix}}$$&lt;/div&gt;
&lt;div class="math"&gt;$$B ={\begin{bmatrix} 
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0\\
\end{bmatrix}}$$&lt;/div&gt;
&lt;p&gt;then their boolean product is the matrix:&lt;/p&gt;
&lt;div class="math"&gt;$$C ={\begin{bmatrix} 
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1\\
\end{bmatrix}}$$&lt;/div&gt;
&lt;p&gt;To calculate the boolean product we can perform the calculations as we
described them. We can do something different, though, which is our
objective here. In particular, we will use the &lt;em&gt;four Russians
algorithm&lt;/em&gt;&lt;a href='#arlazarov:1970' id='ref-arlazarov:1970-1'&gt;[2]&lt;/a&gt;, as described in section 6.6
of &lt;a href='#aho:1974' id='ref-aho:1974-1'&gt;[1]&lt;/a&gt;. In what follows, we will assume that the two matrices
&lt;span class="math"&gt;\(A\)&lt;/span&gt; and &lt;span class="math"&gt;\(B\)&lt;/span&gt; have dimensions &lt;span class="math"&gt;\(n \times n\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;We start by partitioning the two matrices in &lt;span class="math"&gt;\(\lceil{n / \lg n}\rceil\)&lt;/span&gt;
pieces, the &lt;span class="math"&gt;\(A\)&lt;/span&gt; matrix column-wise and the &lt;span class="math"&gt;\(B\)&lt;/span&gt; matrix row-wise:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/four-russians/matrix_partition_h.png" width="300"/&gt;
&lt;img src="https://louridas.github.io/assignments/four-russians/matrix_partition_v.png" width="300"/&gt;&lt;/p&gt;
&lt;p&gt;That means that each piece of &lt;span class="math"&gt;\(A\)&lt;/span&gt; will have dimensions &lt;span class="math"&gt;\(n \times
\lfloor{\lg n}\rfloor\)&lt;/span&gt; and each piece of &lt;span class="math"&gt;\(B\)&lt;/span&gt; will have dimensions
&lt;span class="math"&gt;\(\lfloor{\lg n}\rfloor \times n\)&lt;/span&gt;. If &lt;span class="math"&gt;\(n\)&lt;/span&gt; is not divided by &lt;span class="math"&gt;\(\lg n\)&lt;/span&gt;, we
pad the last part of &lt;span class="math"&gt;\(A\)&lt;/span&gt; with zero columns and the last part of &lt;span class="math"&gt;\(B\)&lt;/span&gt;
with zero rows.&lt;/p&gt;
&lt;p&gt;Now note that if we have two matrices &lt;span class="math"&gt;\(Α\)&lt;/span&gt; and &lt;span class="math"&gt;\(B\)&lt;/span&gt;, not necessarily
boolean, with dimensions &lt;span class="math"&gt;\(n\times n\)&lt;/span&gt;, and we partition them as we
described, their product &lt;span class="math"&gt;\(AB\)&lt;/span&gt; can be derived by taking the products of
the parts &lt;span class="math"&gt;\(A_i \times B_i\)&lt;/span&gt; and sum everything together:&lt;/p&gt;
&lt;div class="math"&gt;$$ A B = \sum _{i=1}^{\lceil{n / \lg n}\rceil}A_{i}B_{i}$$&lt;/div&gt;
&lt;p&gt;You can verify that each of &lt;span class="math"&gt;\(A_i B_i\)&lt;/span&gt; is a matrix with dimensions 
&lt;span class="math"&gt;\(n \times n\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;In our example, we have:&lt;/p&gt;
&lt;div class="math"&gt;$$A_1 ={\begin{bmatrix} 
1 &amp;amp; 1 \\
0 &amp;amp; 0 \\
1 &amp;amp; 0 \\
1 &amp;amp; 0 \\
1 &amp;amp; 0 \\
\end{bmatrix}}$$&lt;/div&gt;
&lt;p&gt;and:&lt;/p&gt;
&lt;div class="math"&gt;$$B_1 ={\begin{bmatrix} 
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
\end{bmatrix}}$$&lt;/div&gt;
&lt;p&gt;so:&lt;/p&gt;
&lt;div class="math"&gt;$$A_1 B_1 ={\begin{bmatrix} 
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\
\end{bmatrix}}$$&lt;/div&gt;
&lt;p&gt;Continuing, we have:&lt;/p&gt;
&lt;div class="math"&gt;$$A_2 ={\begin{bmatrix} 
0 &amp;amp; 0 \\
1 &amp;amp; 1 \\
0 &amp;amp; 1 \\
0 &amp;amp; 1 \\
1 &amp;amp; 0 \\
\end{bmatrix}}$$&lt;/div&gt;
&lt;p&gt;and:&lt;/p&gt;
&lt;div class="math"&gt;$$B_2 ={\begin{bmatrix} 
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\
\end{bmatrix}}$$&lt;/div&gt;
&lt;p&gt;so:&lt;/p&gt;
&lt;div class="math"&gt;$$A_2 B_2 ={\begin{bmatrix} 
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\
1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 
\end{bmatrix}}$$&lt;/div&gt;
&lt;p&gt;Finally, we have:&lt;/p&gt;
&lt;div class="math"&gt;$$A_3 ={\begin{bmatrix} 
0 &amp;amp; 0 \\
1 &amp;amp; 0 \\
0 &amp;amp; 0 \\
1 &amp;amp; 0 \\
1 &amp;amp; 0 \\
\end{bmatrix}}$$&lt;/div&gt;
&lt;p&gt;and:&lt;/p&gt;
&lt;div class="math"&gt;$$B_3 ={\begin{bmatrix} 
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
\end{bmatrix}}$$&lt;/div&gt;
&lt;p&gt;so:&lt;/p&gt;
&lt;div class="math"&gt;$$A_3 B_3 ={\begin{bmatrix} 
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 
\end{bmatrix}}$$&lt;/div&gt;
&lt;p&gt;If we take the boolean sum of the products, we get:&lt;/p&gt;
&lt;div class="math"&gt;$$A_1 B_1 + A_2 B_2 + A_3 B_3 =
{\begin{bmatrix} 
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\
\end{bmatrix}}
+
{\begin{bmatrix} 
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\
1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 
\end{bmatrix}}
+
{\begin{bmatrix} 
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 
\end{bmatrix}} = 
{\begin{bmatrix} 
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 
\end{bmatrix}}$$&lt;/div&gt;
&lt;p&gt;which is the same result as the one we got before.&lt;/p&gt;
&lt;p&gt;Let us focus on how we can calculate &lt;span class="math"&gt;\(A_i B_i\)&lt;/span&gt;, taking as example &lt;span class="math"&gt;\(A_2
B_2\)&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first row of &lt;span class="math"&gt;\(A_2 B_2\)&lt;/span&gt; is the result of taking none of the rows
  of &lt;span class="math"&gt;\(B_2\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The second row of &lt;span class="math"&gt;\(A_2 B_2\)&lt;/span&gt; is the result of the addition of the two
  rows of &lt;span class="math"&gt;\(B_2\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The third row of &lt;span class="math"&gt;\(A_2 B_2\)&lt;/span&gt; is the second row of &lt;span class="math"&gt;\(B_2\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The fourth row of &lt;span class="math"&gt;\(A_2 B_2\)&lt;/span&gt; is the second row of &lt;span class="math"&gt;\(B_2\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The fifth row of  &lt;span class="math"&gt;\(A_2 B_2\)&lt;/span&gt; is the first row of &lt;span class="math"&gt;\(B_2\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Therefore, each row of &lt;span class="math"&gt;\(A_2 B_2\)&lt;/span&gt; is the result of taking the boolean
sum of those rows of &lt;span class="math"&gt;\(B_2\)&lt;/span&gt; for which the elements of the corresponding
row of &lt;span class="math"&gt;\(A\)&lt;/span&gt; is equal to one. This holds in general. Suppose that:&lt;/p&gt;
&lt;div class="math"&gt;$$A_i = 
{\begin{bmatrix}
0 &amp;amp; 1 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 1 \\
1 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 0 &amp;amp; 1 \\
1 &amp;amp; 1 &amp;amp; 1 \\
0 &amp;amp; 1 &amp;amp; 1 \\
\end{bmatrix}}
$$&lt;/div&gt;
&lt;p&gt;and:&lt;/p&gt;
&lt;div class="math"&gt;$$ B_i =
{\begin{bmatrix}
0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\
\end{bmatrix}}
$$&lt;/div&gt;
&lt;p&gt;then:&lt;/p&gt;
&lt;div class="math"&gt;$$A_i B_i = 
{\begin{bmatrix}
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\
0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1
\end{bmatrix}}
$$&lt;/div&gt;
&lt;p&gt;We can see that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first row of &lt;span class="math"&gt;\(A_i B_i\)&lt;/span&gt; is equal to the second row of &lt;span class="math"&gt;\(B_i\)&lt;/span&gt;, as
  indicated by the first row of &lt;span class="math"&gt;\(A_i\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The second row of &lt;span class="math"&gt;\(A_i B_i\)&lt;/span&gt; is equal to zero, as indicated by the
  second row of &lt;span class="math"&gt;\(A_i\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The third row of &lt;span class="math"&gt;\(A_i B_i\)&lt;/span&gt; is equal to the boolean sum of the first
  and the second rows of &lt;span class="math"&gt;\(B_i\)&lt;/span&gt;, as indicated by  the third row of
  &lt;span class="math"&gt;\(A_i\)&lt;/span&gt;. &lt;/li&gt;
&lt;li&gt;And so on for the remaining lines; e.g., the seventh row of &lt;span class="math"&gt;\(A_i B_i\)&lt;/span&gt;
  is equal to the boolean sum of all the rows of &lt;span class="math"&gt;\(B_i\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This leads to an idea for speeding up our calculations. Since each row
of the products &lt;span class="math"&gt;\(A_i B_i\)&lt;/span&gt; is the boolean sum of some rows of &lt;span class="math"&gt;\(B_i\)&lt;/span&gt;, we
can pre-compute all possible boolean sums of rows of &lt;span class="math"&gt;\(B_i\)&lt;/span&gt; and use
each time the sum indicated by the corresponding row of &lt;span class="math"&gt;\(A_i\)&lt;/span&gt;. In this
way we arrive at the following algorithm:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/four-russians/four_russians_algorithm.png" width="600"&gt;&lt;/p&gt;
&lt;p&gt;In lines 1&amp;ndash;3 we calculate &lt;span class="math"&gt;\(\lfloor{\lg n}\rfloor\)&lt;/span&gt; and we
initialize matrix &lt;span class="math"&gt;\(C\)&lt;/span&gt;, which will contain the result of the
multiplication. The function &lt;span class="math"&gt;\(\texttt{InitΤοZero(}M\texttt{)}\)&lt;/span&gt;
initializes its argument to zero.&lt;/p&gt;
&lt;p&gt;In each iteration of the loop of lines 4&amp;ndash;19 we calculate a
product &lt;span class="math"&gt;\(C_i = A_i B_i\)&lt;/span&gt; and we add it in &lt;span class="math"&gt;\(C\)&lt;/span&gt;. Lines 5&amp;ndash;15
calculate all possible sums of rows of &lt;span class="math"&gt;\(B_i\)&lt;/span&gt; and store them in matrix
&lt;span class="math"&gt;\(\mathit{RS}\)&lt;/span&gt; (rowsums), with dimensions &lt;span class="math"&gt;\(2^m \times n\)&lt;/span&gt;. To do that,
we start from &lt;span class="math"&gt;\(\mathit{RS}[0]\)&lt;/span&gt;, which is equal to a zero vector, and
we proceed by adding to the previous sums rows from matrix &lt;span class="math"&gt;\(B_i\)&lt;/span&gt;. The
call &lt;span class="math"&gt;\(\texttt{RowFromBottom(}B_{i}, k + 1\texttt{)}\)&lt;/span&gt; returns the &lt;span class="math"&gt;\(k+1\)&lt;/span&gt;
row counting from the end of matrix &lt;span class="math"&gt;\(B_i\)&lt;/span&gt;. Lines 9&amp;ndash;15 add rows
from &lt;span class="math"&gt;\(B_i\)&lt;/span&gt; to &lt;span class="math"&gt;\(\mathit{RS}[j - 2^k]\)&lt;/span&gt;, which is a sum that has already
been calculated, so that we get new sums. We use a variable
&lt;span class="math"&gt;\(\mathit{bp}\)&lt;/span&gt; (between powers) to know when to increase &lt;span class="math"&gt;\(k\)&lt;/span&gt;:
&lt;span class="math"&gt;\(\mathit{bp}\)&lt;/span&gt; counts how many numbers lie between two successive
powers of two. Once we have calculated all possible boolean row sums
and we have stored them in the &lt;span class="math"&gt;\(\mathit{RS}\)&lt;/span&gt; matrix, we calculate each
&lt;span class="math"&gt;\(C_i = A_i B_i\)&lt;/span&gt;, in lines 16&amp;ndash;18. The call
&lt;span class="math"&gt;\(\texttt{Num(}A_{i}[j]\texttt{)}\)&lt;/span&gt; returns the decimal number that
corresponds to the &lt;span class="math"&gt;\(j\)&lt;/span&gt;th row of matrix &lt;span class="math"&gt;\(A_i\)&lt;/span&gt;. For example, if
&lt;span class="math"&gt;\(A_{i}[j] = [1, 0, 1]\)&lt;/span&gt;, &lt;span class="math"&gt;\(\texttt{Num(}A_{i}[j]\texttt{)}\)&lt;/span&gt; returns 5.
Finally, we add each &lt;span class="math"&gt;\(C_i\)&lt;/span&gt; to &lt;span class="math"&gt;\(C\)&lt;/span&gt; inline 19. &lt;/p&gt;
&lt;p&gt;Graphs give us an opportunity to see an application of boolean matrix
multiplication. If &lt;span class="math"&gt;\(G = (V, E)\)&lt;/span&gt; is a directed graph, we can form the
graph &lt;span class="math"&gt;\(G* = (V, E*)\)&lt;/span&gt; that has the same vertices as &lt;span class="math"&gt;\(G\)&lt;/span&gt; but one edge
for any pair of nodes that are connected in &lt;span class="math"&gt;\(G\)&lt;/span&gt; (and not just the
direct neighbors). The graph &lt;span class="math"&gt;\(G*\)&lt;/span&gt; is called the &lt;em&gt;transitive closure&lt;/em&gt;
of &lt;span class="math"&gt;\(G\)&lt;/span&gt;. Suppose we have the graph:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/four-russians/graph.png" width="600"/&gt;&lt;/p&gt;
&lt;p&gt;Then, the transitive closure of &lt;span class="math"&gt;\(G\)&lt;/span&gt; is the graph &lt;span class="math"&gt;\(G*\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/four-russians/graph_transitive_closure.png" width="600"/&gt;&lt;/p&gt;
&lt;p&gt;To calculate the transitive closure of a graph we can use boolean
matrix multiplication. If &lt;span class="math"&gt;\(A\)&lt;/span&gt; is the adjacency matrix of graph &lt;span class="math"&gt;\(G\)&lt;/span&gt;,
then &lt;span class="math"&gt;\(A^2 = A A\)&lt;/span&gt; is the adjacency matrix of the graph that we get from
&lt;span class="math"&gt;\(G\)&lt;/span&gt; if we add to &lt;span class="math"&gt;\(G\)&lt;/span&gt; an edge for every pair of nodes that are
connected with a path of length two. Similarly, &lt;span class="math"&gt;\(A^3 = A^2 A\)&lt;/span&gt; is the
adjacency matrix of the graph that we get grom &lt;span class="math"&gt;\(G\)&lt;/span&gt; if we add to &lt;span class="math"&gt;\(G\)&lt;/span&gt; an
edge for every pair of nodes that are connected with a path of length
two or three. In general, &lt;span class="math"&gt;\(A^n = A^{n-1} A\)&lt;/span&gt; is the adjacency matrix of
the graph we get if we add to &lt;span class="math"&gt;\(G\)&lt;/span&gt; an edge for every pair of nodes that
are connected with a path of length 2, 3, &lt;span class="math"&gt;\(\ldots\)&lt;/span&gt;, &lt;span class="math"&gt;\(n - 1\)&lt;/span&gt;. For this
to work, we assume that each node in &lt;span class="math"&gt;\(G\)&lt;/span&gt; is connected to itself, so in
the adjancency matrix of &lt;span class="math"&gt;\(G\)&lt;/span&gt; we put ones down the left to right
diagonal. More formally, we use as adjacency matrix the matrix &lt;span class="math"&gt;\(A \vee
\mathbf{I}\)&lt;/span&gt;, where &lt;span class="math"&gt;\(A\)&lt;/span&gt; is the initial adjacency matrix and
&lt;span class="math"&gt;\(\mathbf{I}\)&lt;/span&gt; is the identity matrix.&lt;/p&gt;
&lt;p&gt;In this assignment you will implement a program that finds the
transitive closure of a graph using the four Russians algorithm.&lt;/p&gt;
&lt;h2&gt;Requirements&lt;/h2&gt;
&lt;p&gt;You will write a program called &lt;code&gt;four_russians.py&lt;/code&gt;. The program will
be called in two ways.&lt;/p&gt;
&lt;p&gt;If the program is called with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python four_russians.py &amp;lt;input_file_1&amp;gt; &amp;lt;input_file_2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;where &lt;code&gt;&amp;lt;input_file_1&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;input_file_2&amp;gt;&lt;/code&gt; are the names of two files
containing boolean matrices, the program will output their boolean
product. For example, if the user specifies files
&lt;a href="https://louridas.github.io/assignments/four-russians/array_1.txt"&gt;array_1.txt&lt;/a&gt; and
&lt;a href="https://louridas.github.io/assignments/four-russians/array_2.txt"&gt;array_2.txt&lt;/a&gt;, the program will output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;1,0,1,1,0,1,1,0,0,0,1,0,0
1,0,1,1,1,1,1,0,1,1,1,1,0
1,1,0,0,1,0,0,0,0,0,1,0,1
1,0,0,1,1,0,1,1,1,1,1,1,1
0,1,1,1,0,0,1,0,1,1,1,1,1
1,1,1,0,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,0,1,1,1
1,0,1,1,1,1,1,0,1,0,1,1,0
1,1,1,1,0,1,1,1,1,1,1,1,1
1,0,1,1,0,1,1,1,1,0,1,0,1
1,1,1,1,0,0,1,0,0,0,0,0,1
1,1,0,1,1,0,1,1,1,1,1,1,1
1,1,1,1,0,1,0,1,1,0,0,1,1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If the program is called with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python four_russians.py &amp;lt;input_file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;where &lt;code&gt;&amp;lt;input_file&amp;gt;&lt;/code&gt; is the name of a file that contains a graph, the
program will output the transitive closure of the graph. The input
file will describe the graph by giving each edge in a line. For
example, a file starting with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0 1
1 2
2 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;specifies that node 0 is connected with node 1, node 1 is connected
with node 2, and node 2 is connected to node 3.&lt;/p&gt;
&lt;p&gt;The transitive closure will be described in the same way, with an edge
per line. The lines must be output in ascending order. For example, if
the program is given as input the file
&lt;a href="https://louridas.github.io/assignments/four-russians/graph_1.txt"&gt;graph_1.txt&lt;/a&gt;, which corresponds to the graph we
used above, we'll get the following output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0 0
0 1
0 2
0 3
0 4
0 5
1 1
1 2
1 3
1 4
1 5
2 2
2 3
2 4
2 5
3 3
3 4
3 5
4 4
4 5
5 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Notes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The algorithm was first published in Russian, as "Об экономном
  построении транзитивного замыкания ориентированного графа", Доклады
  Академии Наук СССР 134 (3), 1970. &lt;/li&gt;
&lt;li&gt;The algorithm took its name because it was believed that its
  creators were Russians. However, although all of them lived in the
  Soviet Union, it is not certain that they were Russians.&lt;/li&gt;
&lt;li&gt;The algorithm is useful because it allows us to perform the boolean
  multiplication of two matrices in time &lt;span class="math"&gt;\(Ο(n^3/\lg n)\)&lt;/span&gt;. This can be
  improved to &lt;span class="math"&gt;\(Ο(n^2/\lg n)\)&lt;/span&gt; if we implement it using bitwise
  operators, better than the &lt;span class="math"&gt;\(O(n^3)\)&lt;/span&gt; time taken if we just follow the
  definition of matrix multiplication.&lt;/li&gt;
&lt;li&gt;Beyond boolean multiplication, the underlying logic of the algorithm
  can be applied to the calculation of the distance between two
  strings, DNA sequence alignment, and cryptography. Check the
  &lt;a href="https://en.wikipedia.org/wiki/Method_of_Four_Russians"&gt;Wikipedia
  article&lt;/a&gt; for
  more details.&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;hr&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;div class='bibliography'&gt;&lt;ol&gt;&lt;li id='aho:1974'&gt;Alfred&amp;nbsp;V. Aho, John&amp;nbsp;E. Hopcroft, and Jeffrey&amp;nbsp;D. Ullman.
&lt;em&gt;The Design and Analysis of Computer Algorithms&lt;/em&gt;.
Addison-Wesley, Reading, MA, 1974. &lt;a class="cite-backref" href="#ref-aho:1974-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='arlazarov:1970'&gt;V.&amp;nbsp;L. Arlazarov, Y.&amp;nbsp;A. Dinitz, and I.&amp;nbsp;A. Kronrod, M.&amp;nbsp;A.&amp;nbsp;Faradzhev.
On economical construction of the transitive closure of an oriented graph.
&lt;em&gt;Doklady Akademii Nauk SSSR&lt;/em&gt;, 194(3):487–488, 1970. &lt;a class="cite-backref" href="#ref-arlazarov:1970-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><category term="assignments"></category></entry><entry><title>Polyominoes</title><link href="https://louridas.github.io/assignments/polyominoes/" rel="alternate"></link><published>2018-06-17T00:00:00+03:00</published><updated>2018-06-17T00:00:00+03:00</updated><author><name>Panos Louridas</name></author><id>tag:louridas.github.io,2018-06-17:/assignments/polyominoes/</id><summary type="html">&lt;p&gt;In &lt;a href="https://en.wikipedia.org/wiki/Arthur_C._Clarke"&gt;Arthur C.
Clarke&lt;/a&gt;'s book
&lt;a href="https://en.wikipedia.org/wiki/Imperial_Earth"&gt;Imperial Earth&lt;/a&gt;, the
main character has to solve two problems with
&lt;a href="https://en.wikipedia.org/wiki/Pentomino"&gt;pentominoes&lt;/a&gt;. A pentomino is
a polygon that is made up from five equal square tiles placed such
that every two tiles share one side. There are 12 different
pentominoes if we do not …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In &lt;a href="https://en.wikipedia.org/wiki/Arthur_C._Clarke"&gt;Arthur C.
Clarke&lt;/a&gt;'s book
&lt;a href="https://en.wikipedia.org/wiki/Imperial_Earth"&gt;Imperial Earth&lt;/a&gt;, the
main character has to solve two problems with
&lt;a href="https://en.wikipedia.org/wiki/Pentomino"&gt;pentominoes&lt;/a&gt;. A pentomino is
a polygon that is made up from five equal square tiles placed such
that every two tiles share one side. There are 12 different
pentominoes if we do not take into account rotations and reflections:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/polyominoes/pentominoes_fixed.png" width="600"/&gt;&lt;/p&gt;
&lt;p&gt;The two problems in the book were:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Can we fill a rectangle with dimensions &lt;span class="math"&gt;\(6\times 10\)&lt;/span&gt; using these 12
   pentominoes? It turns out that the answer is yes, and there are
   2339 different solutions. Here is one of them:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/polyominoes/pentominoes_6_10.png" width="300"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Can we fill a rectangle with dimensions &lt;span class="math"&gt;\(3\times 20\)&lt;/span&gt; using these 12
  pentominoes? Again, it turns out that the answer is yes, but there
  are only two solutions. Here is one of them:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/polyominoes/pentominoes_3_20.png" width="600"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As you can see, the pentominoes in these rectangles can be rotated or
reflected, horizontally or vertically. But if we do such
transformations, how many different shapes can we produce?&lt;/p&gt;
&lt;p&gt;If we allow a pentomino to be transformed, then we no longer have only
12 possible shapes. For example, take the pentomino:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/polyominoes/pentomino_f.png" width="100"/&gt;&lt;/p&gt;
&lt;p&gt;If we rotate it or reflect it, we can get the following eight shapes:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/polyominoes/pentominoes_f_free.png" width="600"/&gt;&lt;/p&gt;
&lt;p&gt;In total, there are 63 different pentominoes if we allow rotations and
reflections. When rotations and reflections are not allowed, we call
the set of pentominoes we have &lt;em&gt;free&lt;/em&gt;; these are the 12 pentominoes we
saw at the beginning. Otherwise, if rotations and reflections are
allowed, we have 63 &lt;em&gt;fixed&lt;/em&gt; pentominoes.&lt;/p&gt;
&lt;p&gt;We can now generalize and work with a different number of tiles
instead of five. A
&lt;a href="https://en.wikipedia.org/wiki/Polyomino"&gt;polyomino&lt;/a&gt; is a geometrical
shape consisting of a number of square tiles, with each two of them
sharing a side. As in pentominoes, polyominoes can be fixed or free.
We are interested in finding a way to count the number of fixed
polyominos, for every possible number of tiles &lt;span class="math"&gt;\(n\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;To find that count, we can work as follows. We will take pentominoes
as our example. We create a square lattice, on which we will place the
pentominoes. All pentominoes will be placed so that they cover tile
&lt;span class="math"&gt;\((0, 0)\)&lt;/span&gt;. Given that, the pentominoes may extend to the grayed tiles
of the following shape:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/polyominoes/lattice_pentominoes.png" width="450"/&gt;&lt;/p&gt;
&lt;p&gt;The bold line indicates the tiles whose coordinates are:&lt;/p&gt;
&lt;div class="math"&gt;$$ \{\, (x, y)\ |\ (y &amp;gt;0)\ \mathrm{or}\ (y = 0)\ \mathrm{and}\ x \ge 0 \,\} $$&lt;/div&gt;
&lt;p&gt;Then, to find the different pentominoes, we take five tiles such that
every two of them share an edge and one of them covers &lt;span class="math"&gt;\((0, 0)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Now, let's define a graph where each node is one of the grayed tiles
and its neighbors are the adjacent squared tiles:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/polyominoes/graph_pentominoes.png" width="550"/&gt;&lt;/p&gt;
&lt;p&gt;Then, the pentominoes are the connected subgraphs of the graph that
contain five nodes.&lt;/p&gt;
&lt;p&gt;It follows that to find how many pentominoes there are, we have to
find the number of connected subgraphs having five nodes. In general,
if we have polyominoes of size &lt;span class="math"&gt;\(n\)&lt;/span&gt;, the logic remains the same. We
construct the corresponding graph and we count the number of connected
subgraphs with &lt;span class="math"&gt;\(n\)&lt;/span&gt; nodes. To find these subgraphs, we can use the
following algorithm:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/polyominoes/count_fixed_polyominoes_algorithm_nc.png" width="600"/&gt;&lt;/p&gt;
&lt;p&gt;The algorithm is recursive. It takes as arguments the graph that we
have constructed (&lt;span class="math"&gt;\(G\)&lt;/span&gt;), a set of tiles that we need to try
(&lt;span class="math"&gt;\(\mathit{untried}\)&lt;/span&gt;), the size of the polyomino (&lt;span class="math"&gt;\(n\)&lt;/span&gt;) and the current
polyomino under construction (&lt;span class="math"&gt;\(p\)&lt;/span&gt;). We call the algorithm passing as
&lt;span class="math"&gt;\(\mathit{untried}\)&lt;/span&gt; the set &lt;span class="math"&gt;\(\{(0, 0)\}\)&lt;/span&gt; and as the current polyomino
&lt;span class="math"&gt;\(p\)&lt;/span&gt; an empty list.&lt;/p&gt;
&lt;p&gt;When we start, we initialize the counter representing the number of
polyominoes to zero (line 1). The algorithm executes as long as the
set &lt;span class="math"&gt;\(\mathit{untried}\)&lt;/span&gt; is not empty. We take out one element from the
set, that is, a node that we call &lt;span class="math"&gt;\(u\)&lt;/span&gt; (line 3), and we add it to the
current polyomino (line 5). If the current polyomino has size equal to
&lt;span class="math"&gt;\(n\)&lt;/span&gt;, we increase the counter by one (lines 5&amp;ndash;6). Otherwise, 
in lines 8&amp;ndash;13 we find the neighbors of &lt;span class="math"&gt;\(u\)&lt;/span&gt; for which the
following hold:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The do not belong to set &lt;span class="math"&gt;\(\mathit{untried}\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;They do not belong in the current polyomino under construction.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;They are not neighbors of the other nodes, apart from &lt;span class="math"&gt;\(u\)&lt;/span&gt;, that
   belong to &lt;span class="math"&gt;\(p\)&lt;/span&gt;: by &lt;span class="math"&gt;\(p \setminus u\)&lt;/span&gt; we done the nodes of &lt;span class="math"&gt;\(p\)&lt;/span&gt; apart
   from &lt;span class="math"&gt;\(u\)&lt;/span&gt;. At this point you may wonder: &amp;ldquo;Well,
   &lt;span class="math"&gt;\(\mathit{untried}\)&lt;/span&gt; does contain the neighbors of the polyomino
   under construction, right? Why do we need this check since we
   already check that &lt;span class="math"&gt;\(v \notin \mathit{untried}\)&lt;/span&gt;?&amp;rdquo;. The answer
   is no, it does not necessarily contain all the neighbors of the
   polyomino under construction, because each time we go through line
   3 we remove an element from &lt;span class="math"&gt;\(\mathit{untried}\)&lt;/span&gt;, so a neighbor may
   be one of the removed elements.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When we find these neighbors we create a new set of tiles that we must
try (line 12) and we call the graph recursively (line 13). When the
recursive call returns, we add to the counter the value returned from
the call. Before the next iteration of the loop of lines 2&amp;ndash;14,
we remove node &lt;span class="math"&gt;\(u\)&lt;/span&gt; from &lt;span class="math"&gt;\(p\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3&gt;Requirements&lt;/h3&gt;
&lt;p&gt;You will write a program called &lt;code&gt;count_fixed_polyominoes.py&lt;/code&gt;. Your
program will be called as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python count_fixed_polyominoes.py &lt;span class="o"&gt;[&lt;/span&gt;-p&lt;span class="o"&gt;]&lt;/span&gt; n 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The program will construct and count all fixed polyominoes of size &lt;code&gt;n&lt;/code&gt;
and print out their number. If the user passes &lt;code&gt;-p&lt;/code&gt;, the program will
also output the graph that is constructed. In your program:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;You should represent the graph using adjacency lists, not the
  adjacency matrix.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If &lt;code&gt;-p&lt;/code&gt; is given, the nodes in the adjacency lists will have to be
  printed out in counter-clockwize order; see the examples below. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You can use the &lt;code&gt;pprint&lt;/code&gt; library for printing the graph and the
  &lt;code&gt;argparse&lt;/code&gt; or &lt;code&gt;sys&lt;/code&gt; library for handling the program arguments.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Examples&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Example 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If the program is called with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python count_fixed_polyominoes.py -p &lt;span class="m"&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the program will output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{(-1, 1): [(0, 1)],
 (0, 0): [(1, 0), (0, 1)],
 (0, 1): [(1, 1), (0, 2), (-1, 1), (0, 0)],
 (0, 2): [(0, 1)],
 (1, 0): [(2, 0), (1, 1), (0, 0)],
 (1, 1): [(0, 1), (1, 0)],
 (2, 0): [(1, 0)]}
6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Example 2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If the program is called with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python count_fixed_polyominoes.py -p &lt;span class="m"&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the output will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{(-2, 1): [(-1, 1)],
 (-1, 1): [(0, 1), (-1, 2), (-2, 1)],
 (-1, 2): [(0, 2), (-1, 1)],
 (0, 0): [(1, 0), (0, 1)],
 (0, 1): [(1, 1), (0, 2), (-1, 1), (0, 0)],
 (0, 2): [(1, 2), (0, 3), (-1, 2), (0, 1)],
 (0, 3): [(0, 2)],
 (1, 0): [(2, 0), (1, 1), (0, 0)],
 (1, 1): [(2, 1), (1, 2), (0, 1), (1, 0)],
 (1, 2): [(0, 2), (1, 1)],
 (2, 0): [(3, 0), (2, 1), (1, 0)],
 (2, 1): [(1, 1), (2, 0)],
 (3, 0): [(2, 0)]}
19
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Example 3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If the program is called with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python count_fixed_polyominoes.py -p &lt;span class="m"&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the output will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{(-3, 1): [(-2, 1)],
 (-2, 1): [(-1, 1), (-2, 2), (-3, 1)],
 (-2, 2): [(-1, 2), (-2, 1)],
 (-1, 1): [(0, 1), (-1, 2), (-2, 1)],
 (-1, 2): [(0, 2), (-1, 3), (-2, 2), (-1, 1)],
 (-1, 3): [(0, 3), (-1, 2)],
 (0, 0): [(1, 0), (0, 1)],
 (0, 1): [(1, 1), (0, 2), (-1, 1), (0, 0)],
 (0, 2): [(1, 2), (0, 3), (-1, 2), (0, 1)],
 (0, 3): [(1, 3), (0, 4), (-1, 3), (0, 2)],
 (0, 4): [(0, 3)],
 (1, 0): [(2, 0), (1, 1), (0, 0)],
 (1, 1): [(2, 1), (1, 2), (0, 1), (1, 0)],
 (1, 2): [(2, 2), (1, 3), (0, 2), (1, 1)],
 (1, 3): [(0, 3), (1, 2)],
 (2, 0): [(3, 0), (2, 1), (1, 0)],
 (2, 1): [(3, 1), (2, 2), (1, 1), (2, 0)],
 (2, 2): [(1, 2), (2, 1)],
 (3, 0): [(4, 0), (3, 1), (2, 0)],
 (3, 1): [(2, 1), (3, 0)],
 (4, 0): [(3, 0)]}
63
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Example 4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If the program is called with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python count_fixed_polyominoes.py &lt;span class="m"&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the output will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;36446
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Example 5&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If the program is called with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python count_fixed_polyominoes.py &lt;span class="m"&gt;15&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the output will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;27394666
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Other Examples&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;For polyominoes of sizes up to and including 15, their number is as in
the following table:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Polyomino Size&lt;/th&gt;
&lt;th&gt;Number of Fixed Polyominoes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;216&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;760&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;2725&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9910&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;36446&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;135268&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;505861&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;1903890&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;7204874&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;27394666&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Arthuc C. Clarke learned about polyominoes from director &lt;a href="https://en.wikipedia.org/wiki/Stanley_Kubrick"&gt;Stanley
  Kubrick&lt;/a&gt; during the
  shooting of &lt;a href="https://en.wikipedia.org/wiki/2001:_A_Space_Odyssey_(film)"&gt;2001: A Space
  Odyssey&lt;/a&gt;;
  he then wove them into his book &lt;a href='#clarke:1975' id='ref-clarke:1975-1'&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The algorithm that you have to implement in this assignment was
  invented by D. Hugh Redelmeier &lt;a href='#redelmeier:1981' id='ref-redelmeier:1981-1'&gt;[7]&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The Redelmeier algorithm is not fast, as it has exponential
  complexity. The fast algorithm we know, although it still has
  exponential complexity, was invented by Iwan Jensen &lt;a href='#jensen:2001' id='ref-jensen:2001-1'&gt;[6]&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We can frame the problem in three or more dimensions; for details,
  see &lt;a href='#aleksandrowicz:2006' id='ref-aleksandrowicz:2006-1'&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The term &amp;ldquo;polyomino&amp;rdquo; was introduced by Solomon W.
  Golomb in 1954. For more details, see his book &lt;a href='#golomb:1994' id='ref-golomb:1994-1'&gt;[5]&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Polyominoes were introduced to the wider public by Martin Gardner in
  1957 and 1960 in his Scientific American column 
  &lt;a href='#gardner:1957' id='ref-gardner:1957-1'&gt;[3]&lt;/a&gt;&lt;a href='#gardner:1960' id='ref-gardner:1960-1'&gt;[4]&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;hr&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;div class='bibliography'&gt;&lt;ol&gt;&lt;li id='aleksandrowicz:2006'&gt;Gadi Aleksandrowicz and Gill Barequet.
Counting d-dimensional polycubes and nonrectangular planar polyominoes.
In &lt;em&gt;Proceedings of the 12th Annual International Conference on Computing and Combinatorics&lt;/em&gt;, COCOON '06, 418–427. Berlin, Heidelberg, 2006. Springer-Verlag.
URL: &lt;a href="https://doi.org/10.1007/11809678_44"&gt;https://doi.org/10.1007/11809678_44&lt;/a&gt;, &lt;a href="https://doi.org/10.1007/11809678_44"&gt;doi:10.1007/11809678_44&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-aleksandrowicz:2006-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='clarke:1975'&gt;Arthur&amp;nbsp;C. Clarke.
&lt;em&gt;Imperial Earth&lt;/em&gt;.
Gollancz, London, UK, 1965. &lt;a class="cite-backref" href="#ref-clarke:1975-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='gardner:1957'&gt;Martin Gardner.
More about complex dominoes.
&lt;em&gt;Scientific American&lt;/em&gt;, 197(6):126–140, 1957. &lt;a class="cite-backref" href="#ref-gardner:1957-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='gardner:1960'&gt;Martin Gardner.
More about the shapes that can be made with complex dominoes.
&lt;em&gt;Scientific American&lt;/em&gt;, 203(5):186–201, 1960.
&lt;a href="https://doi.org/10.1038/scientificamerican1160-186"&gt;doi:10.1038/scientificamerican1160-186&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-gardner:1960-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='golomb:1994'&gt;Solomon&amp;nbsp;W. Golomb.
&lt;em&gt;Polyominoes&lt;/em&gt;.
Princeton University Press, Princeton, NJ, 2nd edition, 1994. &lt;a class="cite-backref" href="#ref-golomb:1994-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='jensen:2001'&gt;Iwan Jensen.
Enumerations of lattice animals and trees.
&lt;em&gt;Journal of Statistical Physics&lt;/em&gt;, 102(3/4):865–881, 2001.
&lt;a href="https://doi.org/10.1023/A:1004855020556"&gt;doi:10.1023/A:1004855020556&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-jensen:2001-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='redelmeier:1981'&gt;D.&amp;nbsp;Hugh Redelmeier.
Counting polyominoes: yet another attack.
&lt;em&gt;Discrete Mathematics&lt;/em&gt;, 36(2):191–203, 1981. &lt;a class="cite-backref" href="#ref-redelmeier:1981-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><category term="assignments"></category></entry><entry><title>Network Destruction</title><link href="https://louridas.github.io/assignments/network-destruction/" rel="alternate"></link><published>2018-06-16T00:00:00+03:00</published><updated>2018-06-16T00:00:00+03:00</updated><author><name>Panos Louridas</name></author><id>tag:louridas.github.io,2018-06-16:/assignments/network-destruction/</id><summary type="html">&lt;p&gt;While we use algorithms to solve problems with computers, these
problems are not limited to computer science. Moreover, often the same
algorithm may find applications in very different areas. For example,
graphs are used to represent networks, but there is no a-priori
limitation on what kind of networks these may …&lt;/p&gt;</summary><content type="html">&lt;p&gt;While we use algorithms to solve problems with computers, these
problems are not limited to computer science. Moreover, often the same
algorithm may find applications in very different areas. For example,
graphs are used to represent networks, but there is no a-priori
limitation on what kind of networks these may be. We can use graphs
for computer networks, road networks, electricity distribution
networks, or social networks.&lt;/p&gt;
&lt;p&gt;Zeroing in on social networks, we can use them to study the spread of
a disease, as disease can spread through our contacts. We can also use
them to investigate how to halt the spread of a disease. If we have a
network, a graph, in which we have humans connected to other humans to
whom they may spread the disease, we can fight a pandemic if we detect
those persons that we should vaccinate or isolate to minimize contagion.&lt;/p&gt;
&lt;p&gt;Note that when are talking about &amp;ldquo;spread&amp;rdquo;,
&amp;ldquo;pandemic&amp;rdquo;, or &amp;ldquo;contagion&amp;rdquo;, we are not
necessarily referring to a biological disease. We may, for instance,
be interested in stopping the transmission of fake news through a
social network, or arrest the spread of a computer virus, through a
computer network.&lt;/p&gt;
&lt;p&gt;To inoculate a network is to detect those nodes, or graph vertices,
that exert the maximum influence on the whole network. One possible
way to do that is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We find the vertex with the greatest number of links; that is, the
   vertex with the highest &lt;em&gt;degree&lt;/em&gt;. If there are more than one
   vertices with the same, maximum number of links, we may break the
   tie using any rule we want; if vertices are numbered arithmetically,
   we may pick the smallest numbered vertex.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We vaccinate, or isolate, that vertex. In reality, we take it out
   of the graph, as this will ensure that nothing will be spread
   through that node any more.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We go back to step 1.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We repeat steps 1&amp;ndash;3 for as many nodes as we want.&lt;/p&gt;
&lt;p&gt;In the following figures you can see the process of removing four
nodes, selecting each time the node with the highest degree. The nodes
that we remove are painted white, while we use different colors or the
&lt;em&gt;connected components&lt;/em&gt; of the graph.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/network_destruction_degree_0.png" width="400"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/network_destruction_degree_1.png" width="400"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/network_destruction_degree_2.png" width="400"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/network_destruction_degree_3.png" width="400"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/network_destruction_degree_4.png" width="400"&gt;&lt;/p&gt;
&lt;p&gt;We can observe that after removing four nodes the biggest connected
component consists of 17 nodes, which means that if one becomes sick,
the disease will spread to another 16 nodes.&lt;/p&gt;
&lt;p&gt;In many networks a different way of going about the problem is more
efficient. Instead of taking as the node with the greatest influence
the one that has the largest degree, we define the &lt;em&gt;collective
influence&lt;/em&gt; of a node as follows:&lt;/p&gt;
&lt;div class="math"&gt;$$ \mathrm{CI}(i, r) = (k_i -1) \sum_{j \in \vartheta\mathrm{Ball}(i,
r)} (k_j - 1) $$&lt;/div&gt;
&lt;p&gt;In this definition:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(i\)&lt;/span&gt; is the node whose collective influence we are calculating and
  &lt;span class="math"&gt;\(k_i\)&lt;/span&gt; is the degree of node &lt;span class="math"&gt;\(i\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\mathrm{Ball}(i, r)\)&lt;/span&gt; is the set of nodes whose shortest path from
  node &lt;span class="math"&gt;\(i\)&lt;/span&gt; does not exceed &lt;span class="math"&gt;\(r\)&lt;/span&gt;. If you could draw a circle with radius
  &lt;span class="math"&gt;\(r\)&lt;/span&gt; links around node &lt;span class="math"&gt;\(i\)&lt;/span&gt;, nodes &lt;span class="math"&gt;\(j\)&lt;/span&gt; are the nodes that would fall
  inside the circle. If you would prefer to talk in three dimensions,
  they would be the nodes that fall inside the sphere centered at node
  &lt;span class="math"&gt;\(i\)&lt;/span&gt; and having radius &lt;span class="math"&gt;\(r\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\vartheta\mathrm{Ball}(i, r)\)&lt;/span&gt; is the set of nodes whose shortest
  path from node &lt;span class="math"&gt;\(i\)&lt;/span&gt; is exactly &lt;span class="math"&gt;\(r\)&lt;/span&gt;. If you could draw a circle with
  radius &lt;span class="math"&gt;\(r\)&lt;/span&gt; links around node &lt;span class="math"&gt;\(i\)&lt;/span&gt;, nodes &lt;span class="math"&gt;\(j\)&lt;/span&gt; are the nodes that fall
  on the perimeter of the circle. If you would prefer to talk in three
  dimensions, they would be the nodes that fall on the surface of the
  sphere centered at node &lt;span class="math"&gt;\(i\)&lt;/span&gt; and having radius &lt;span class="math"&gt;\(r\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Following the above, to calculate the collective influence of a node
&lt;span class="math"&gt;\(i\)&lt;/span&gt;, we find the nodes whose shortest path from &lt;span class="math"&gt;\(i\)&lt;/span&gt; is equal to &lt;span class="math"&gt;\(r\)&lt;/span&gt;
and we take the sum of the links of each one of them, &lt;span class="math"&gt;\(k_j\)&lt;/span&gt; for node
&lt;span class="math"&gt;\(j\)&lt;/span&gt;, minus one. Finally, we multiply the sum with the number of links
of &lt;span class="math"&gt;\(i\)&lt;/span&gt;, &lt;span class="math"&gt;\(k_i\)&lt;/span&gt;, minus one.&lt;/p&gt;
&lt;p&gt;Using the collective influence, we can now dismantle a network like
this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We calculate the collective influence of every node.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We select the node with the biggest collective influence. If there
   are more than one node with the same collective influence we may
   break the tie using any rule we want; if nodes are numbered
   arithmetically, we may pick the smallest numbered vertex.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We remove that node.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We update the collective influence of the nodes that are affected
   by the removal of the node in step 3. These are the nodes inside
   &lt;span class="math"&gt;\(\mathrm{Ball}(i, r+1)\)&lt;/span&gt;, that is, the nodes that lie inside a
   circle (or a sphere) of radius &lt;span class="math"&gt;\(r+i\)&lt;/span&gt; links away from node &lt;span class="math"&gt;\(i\)&lt;/span&gt;,
   where &lt;span class="math"&gt;\(i\)&lt;/span&gt; is the node that we removed in step 3.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We return to step 2.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We repeat steps 2&amp;ndash;5 for as many nodes as we want.&lt;/p&gt;
&lt;p&gt;To implement this algorithm we need a way to calculate 
&lt;span class="math"&gt;\(\vartheta\mathrm{Ball}(i, r)\)&lt;/span&gt; and &lt;span class="math"&gt;\(\mathrm{Ball}(i, r+1)\)&lt;/span&gt;.
In order to detect the nodes that lie inside a given distance from
another note, it suffices to use a variant of breadth-first search
(BFS), where, as we move further away from our starting node, we keep
count of the links we travel along.&lt;/p&gt;
&lt;p&gt;In the following images you can see how we can protect a network
against contagion by taking out four nodes with the largest, at each
point, collective influence, using &lt;span class="math"&gt;\(r = 2\)&lt;/span&gt;. Again, we use white to
paint the removed nodes, and other colors for the connected
components.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/network_destruction_degree_0.png" width="400"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/network_destruction_ci_1.png" width="400"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/network_destruction_ci_2.png" width="400"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/network_destruction_ci_3.png" width="400"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/network_destruction_ci_4.png" width="400"&gt;&lt;/p&gt;
&lt;p&gt;We can observe that after removing just three nodes, the biggest
connected component has only nine nodes. So, with these three nodes we
managed to dismantle the network more than with the four nodes using
the previous method, that of selecting nodes based on their degree. In
the process, node 10 is removed first, as it has the greatest
collective influence, equal to 63. Verify this calculation to make
sure that you have understood the definition of collective influence.&lt;/p&gt;
&lt;p&gt;Your objective in this assignment is to write a Python program that
will read a file describing a graph and then will select the nodes to
remove using both of the above ways.&lt;/p&gt;
&lt;h3&gt;Requirements&lt;/h3&gt;
&lt;p&gt;You will write a program called &lt;code&gt;network-destruction.py&lt;/code&gt;. You may use
the standard Python libraries &lt;code&gt;argparse&lt;/code&gt; and &lt;code&gt;sys&lt;/code&gt;, but not any
others. Your program will be called as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python network_destruction.py &lt;span class="o"&gt;[&lt;/span&gt;-d&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-r RADIUS&lt;span class="o"&gt;]&lt;/span&gt; num_nodes input_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The meaning of the program arguments is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-d&lt;/code&gt;: optional argument; if given,the program will use the degree of
  each node and not its collective influence. That is, it will operate
  as in the first example we saw. Otherwise, it will operate using the
  collective influence, as in the second example.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-r RADIUS&lt;/code&gt;: optional argument; the program will use the
  value &lt;code&gt;RADIUS&lt;/code&gt; for &lt;span class="math"&gt;\(r\)&lt;/span&gt;, or will default to &lt;span class="math"&gt;\(r = 2\)&lt;/span&gt; otherwise.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;num_nodes&lt;/code&gt;: the number of nodes to remove; mandatory argument.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;input_file&lt;/code&gt;: the name of the file describing the graph.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The file indicated by &lt;code&gt;input_file&lt;/code&gt; will have the format:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;1 2
1 3
2 4
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;that is, it will consist of lines, each one containing two numbers. If
the two numbers are &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, the graph will have a link between
&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The graph is undirected, so we can take it as granted
that it will also have the opposite link, from &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. The nodes
will always be numbers, starting from &lt;span class="math"&gt;\(1\)&lt;/span&gt; and increasing by one: &lt;span class="math"&gt;\(1\)&lt;/span&gt;, &lt;span class="math"&gt;\(2\)&lt;/span&gt;,
&lt;span class="math"&gt;\(\ldots\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The program will about a sequence of lines; each line will contain the
node that is removed and its metric. &lt;/p&gt;
&lt;h3&gt;Examples&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Example 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If we use the example file
&lt;a href="destruction_example_1.txt"&gt;destruction_example_1.txt&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python network_destruction.py -r &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="m"&gt;4&lt;/span&gt; destruction_example_1.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;we will get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;10 63
16 51
20 30
6 9
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That is, we will first take out node 10 with collective influece 63,
then node 16 with collective influence 51, and so on.&lt;/p&gt;
&lt;p&gt;If we use the example file
&lt;a href="destruction_example_1.txt"&gt;destruction_example_1.txt&lt;/a&gt; as: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python network_destruction.py -d &lt;span class="m"&gt;4&lt;/span&gt; destruction_example_1.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;we will get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;25 6
5 5
12 5
6 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This time we first take out node 25 with degree 6, then node 5 with
degree 5, and so on.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If we use the example file
&lt;a href="destruction_example_2.txt"&gt;destruction_example_2.txt&lt;/a&gt; with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python network_destruction.py -d 6 destruction_example_2.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;we will get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;7 5
12 5
26 5
31 5
36 5
42 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If we give:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python network_destruction.py -r &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="m"&gt;6&lt;/span&gt; destruction_example_2.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;we will get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;66 148
12 72
77 64
26 60
47 48
37 45
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The initial graph is:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/destruction_example_2_before.png" width="500"&gt;&lt;/p&gt;
&lt;p&gt;The final graph is:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/destruction_example_2_after.png" width="500"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If we use the example file
&lt;a href="destruction_example_3.txt"&gt;destruction_example_3.txt&lt;/a&gt; with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python network_destruction.py -c &lt;span class="m"&gt;10&lt;/span&gt; destruction_example_3.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;we will get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;114 7
105 6
112 6
125 6
6 4
23 4
34 4
65 4
107 4
124 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If we give:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python network_destruction.py -r &lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt; destruction_example_3.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;we will get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;114 270
105 125
112 75
118 39
125 25
11 24
65 21
138 21
36 15
37 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The initial graph is:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/destruction_example_3_before.png" width="500"&gt;&lt;/p&gt;
&lt;p&gt;The final graph is:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/network-destruction/destruction_example_3_after.png" width="500"&gt;&lt;/p&gt;
&lt;h3&gt;Optionally&lt;/h3&gt;
&lt;p&gt;To get a better understanding of how the algorithm works, a good idea
is to add another switch to the program, &lt;code&gt;-t&lt;/code&gt; (for trace), which will
display the connected components after each node removal.&lt;/p&gt;
&lt;p&gt;Having done that, you can visualize the evolution by adding
functionality to produce a series of images like the ones you have
seen here. To create them you can use
&lt;a href="https://www.graphviz.org/"&gt;graphviz&lt;/a&gt; through its &lt;a href="https://graphviz.readthedocs.io/en/stable/"&gt;Python
interface&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;For an overview of network destruction using collective influence, see
&lt;a href='#kovacs:2015' id='ref-kovacs:2015-1'&gt;[1]&lt;/a&gt;. The algorithm was presented in &lt;a href='#morone:2015' id='ref-morone:2015-1'&gt;[2]&lt;/a&gt;. For
details on its implementation, see &lt;a href='#morone:2016' id='ref-morone:2016-1'&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;hr&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;div class='bibliography'&gt;&lt;ol&gt;&lt;li id='kovacs:2015'&gt;Istv&lt;span class="bibtex-protected"&gt;á&lt;/span&gt;n&amp;nbsp;A. Kov&lt;span class="bibtex-protected"&gt;á&lt;/span&gt;cs and Albert-L&lt;span class="bibtex-protected"&gt;á&lt;/span&gt;szl&lt;span class="bibtex-protected"&gt;ó&lt;/span&gt; Barab&lt;span class="bibtex-protected"&gt;á&lt;/span&gt;si.
Destruction perfected.
&lt;em&gt;Nature&lt;/em&gt;, 524(7563):38–39, 2015.
&lt;a href="https://doi.org/10.1038/524038a"&gt;doi:10.1038/524038a&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-kovacs:2015-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='morone:2015'&gt;Flaviano Morone and Hern&lt;span class="bibtex-protected"&gt;á&lt;/span&gt;n&amp;nbsp;A. Makse.
Destruction perfected.
&lt;em&gt;Nature&lt;/em&gt;, 524(7563):65–68, 2015.
&lt;a href="https://doi.org/10.1038/nature14604"&gt;doi:10.1038/nature14604&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-morone:2015-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='morone:2016'&gt;Flaviano Morone, Byungjoon Min, Lin Bo, Romain Mari, and Hern&lt;span class="bibtex-protected"&gt;á&lt;/span&gt;n&amp;nbsp;A. Makse.
Collective influence algorithm to find influencers via optimal percolation in massively large social media.
&lt;em&gt;Scientific Reports&lt;/em&gt;, 2016.
&lt;a href="https://doi.org/10.1038/srep30062"&gt;doi:10.1038/srep30062&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-morone:2016-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><category term="assignments"></category></entry><entry><title>Social Distancing</title><link href="https://louridas.github.io/assignments/social-distancing/" rel="alternate"></link><published>2018-06-13T00:00:00+03:00</published><updated>2018-06-13T00:00:00+03:00</updated><author><name>Panos Louridas</name></author><id>tag:louridas.github.io,2018-06-13:/assignments/social-distancing/</id><summary type="html">&lt;p&gt;In the covid-19 era, &lt;em&gt;social distancing&lt;/em&gt; has emerged as an important
factor in the fight against the disease. We change
our habits and the way we interact with others, so that we minimize
the chances that the virus can be transmitted.&lt;/p&gt;
&lt;p&gt;Social distancing includes rules about how close we can …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In the covid-19 era, &lt;em&gt;social distancing&lt;/em&gt; has emerged as an important
factor in the fight against the disease. We change
our habits and the way we interact with others, so that we minimize
the chances that the virus can be transmitted.&lt;/p&gt;
&lt;p&gt;Social distancing includes rules about how close we can be to one
another. When we are brought together, we must maintain a certain
distance between ourselves. &lt;/p&gt;
&lt;p&gt;Then a problem emerges: if we have a given space, how many people can
fit into the space, while respecting social distancing rules? And
where should they be placed?&lt;/p&gt;
&lt;p&gt;We can represent each person as a circle whose radius is equal to the
minimum distance we must maintain. Then the problem is to insert the
circles with the given radius inside a shape that describes the space
we want to fill.&lt;/p&gt;
&lt;p&gt;To find where the circles should be placed, we can work as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We put a circle at the point where we want to start the placement
   process.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We put a circle tangent to the first one, noting that each circle
   follows the other.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We interpolate a circle tangent to the last circle and the first
   circle we inserted, noting that it comes between them. We repeat
   this step to add more circles.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is how the process will evolve for the first seven circles:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/social-distancing/circles_1.png" width="700"&gt;&lt;/p&gt;
&lt;p&gt;We can observe that the centers of the circles form a closed polygon.
If we want to continue the process, we must remove from the polygon
vertex &lt;span class="math"&gt;\(C_1\)&lt;/span&gt; and connect directly vertices &lt;span class="math"&gt;\(C_2\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_7\)&lt;/span&gt;. Then we
can interpolate a circle tangent to &lt;span class="math"&gt;\(C_2\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_7\)&lt;/span&gt;, as in the first
panel of the next figure.&lt;/p&gt;
&lt;p&gt;This suggests an idea. Let us call the circles on the perimeter, next
to whom we can attach tangential circles, the &lt;em&gt;front&lt;/em&gt;. To add circles,
we follow these steps: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We add the first two circles (these two form a trivial front).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We find the circle in the front that is closest to our starting
   point. Suppose that this circle &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;. If there are more than one
   circles with the same distance, we pick the one that was inserted
   earliest.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We try to interpolate a circle between &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and its successor in
   the front, &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;. Let us call this circle &lt;span class="math"&gt;\(C_i\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If &lt;span class="math"&gt;\(C_i\)&lt;/span&gt; does not intersect with any of the front's cirles, we
   insert it into our shape and we return to step 2.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Otherwise, we remove from the front the problematic circles and we
   then return to step 2.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/social-distancing/circles_2.png" width="700"&gt;&lt;/p&gt;
&lt;p&gt;If we continue in this way we can insert circles &lt;span class="math"&gt;\(C_9\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_{10}\)&lt;/span&gt;
without a problem. Then, the circle in the front that was inserter
earliest and is closest to our starting point is &lt;span class="math"&gt;\(C_2\)&lt;/span&gt;, whose
successor is &lt;span class="math"&gt;\(C_{10}\)&lt;/span&gt;. If we try to interpolate a circle between &lt;span class="math"&gt;\(C_2\)&lt;/span&gt;
and &lt;span class="math"&gt;\(C_{10}\)&lt;/span&gt;, we will find out that it falls on &lt;span class="math"&gt;\(C_3\)&lt;/span&gt;. According to
step 5, we remove &lt;span class="math"&gt;\(C_2\)&lt;/span&gt; from the front, so now we have &lt;span class="math"&gt;\(C_3\)&lt;/span&gt; followed
by &lt;span class="math"&gt;\(C_{10}\)&lt;/span&gt; in the front. Returning to step 2 we find that &lt;span class="math"&gt;\(C_3\)&lt;/span&gt; is
the front circle closest to the starting point, so we add circle
&lt;span class="math"&gt;\(C_{11}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;That is not a complete algorithm, because step 5 is not clear. We have
termed some circles "problematic", but we have not really defined
which they are that they should be removed from the front.&lt;/p&gt;
&lt;p&gt;If we return to our example, we saw that, as the circle we try to
insert between &lt;span class="math"&gt;\(C_2\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_{10}\)&lt;/span&gt; intersects &lt;span class="math"&gt;\(C_3\)&lt;/span&gt;, we removed &lt;span class="math"&gt;\(C_2\)&lt;/span&gt;
from the front. In general, if the circle &lt;span class="math"&gt;\(C_i\)&lt;/span&gt; that we are trying to
insert tangential to &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_n\)&lt;/span&gt; intersects a circle &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; that
comes before &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; in the front, we remove from the front the circles
from the successor of &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; up to and including &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_j\)&lt;/span&gt;
becomes the new &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;, as you can see in the following figure&amp;mdash;do
not be surprised that the circles do not all have the same radius, we
would like our algorithm to work even when the circles are not equal.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/social-distancing/circles_intersection_1.png" width="700"&gt;&lt;/p&gt;
&lt;p&gt;If the circles are not equal, there is another possibility, that of
&lt;span class="math"&gt;\(C_i\)&lt;/span&gt; intersecting a circle &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; that comes after &lt;span class="math"&gt;\(C_n\)&lt;/span&gt; in the front.
Then we remove from the front the circles from &lt;span class="math"&gt;\(C_n\)&lt;/span&gt; up to and
including the predecessor of &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; becomes the new &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;, as
shown in the following figure.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/social-distancing/circles_intersection_2.png" width="700"&gt;&lt;/p&gt;
&lt;p&gt;Of course, as the centers of the circles that constitute the front are
connected in a closed polygon, a circle that follows another circle
also precedes it, if we continue going round. Moreover, the circle we
are trying to insert can intersect with two circles in the front; see
the next figure. Again, do not be surprised at the strange shape of
the front, we will see that the solution we will find will work even
in such cases, which can arise when the front grows while it fills a
bounded shape.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/social-distancing/circles_loop.png" width="400"&gt;&lt;/p&gt;
&lt;p&gt;To detect the offending circle &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; in all situations, we start from
&lt;span class="math"&gt;\(C_n\)&lt;/span&gt; and we proceed in the front till we meet &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;. We take note of
the first circle that is intersected by &lt;span class="math"&gt;\(C_i\)&lt;/span&gt;, &lt;span class="math"&gt;\(C_j\)&lt;/span&gt;, and the last,
&lt;span class="math"&gt;\(C_{j}'\)&lt;/span&gt;; if &lt;span class="math"&gt;\(C_i\)&lt;/span&gt; intersects only one circle, then &lt;span class="math"&gt;\(C_j = C_{j}'\)&lt;/span&gt;. We
count how many circles are between &lt;span class="math"&gt;\(C_n\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_j\)&lt;/span&gt;, say &lt;span class="math"&gt;\(b_{nj}\)&lt;/span&gt;, and
how many there are between &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_{j}'\)&lt;/span&gt;, say &lt;span class="math"&gt;\(b_{mj'}\)&lt;/span&gt;. If
&lt;span class="math"&gt;\(b_{mj'} &amp;lt; b_{nj}\)&lt;/span&gt;, then we take as &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; the circle &lt;span class="math"&gt;\(C_{j'}\)&lt;/span&gt; that
comes before &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;. Otherwise, we take the circle &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; that comes
after &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;If for every circle in the front we keep not only its successor but
also its predecessor, then we can find &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; in another way. We start
from &lt;span class="math"&gt;\(C_n\)&lt;/span&gt; and we walk one successor circle at a time towards &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;.
At the same time, we start from &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and we walk one predecessor
circle at a time towards &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;. That means that we go one step in each
direction of the front. If we find an intersecting circle in either
direction, or if we go beyond the middle of the front, we stop. If we
stopped because we found an intersecting circle, we check whether we
found it going along the successor or the predecessor circles.&lt;/p&gt;
&lt;p&gt;Our algorithm then evolves to this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We add the first two circles (these two form a trivial front).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We find the circle in the front that is closest to our starting
   point. Suppose that this circle &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;. If there are more than one
   circles with the same distance, we pick the one that was inserted
   earliest.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We try to interpolate a circle between &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and its successor in
   the front, &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;. Let us call this circle &lt;span class="math"&gt;\(C_i\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If &lt;span class="math"&gt;\(C_i\)&lt;/span&gt; does not intersect with any of the front's cirles, we
   insert it into our shape and we return to step 2.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Otherwise:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If &lt;span class="math"&gt;\(C_i\)&lt;/span&gt; intersects a circle &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; that precedes &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;, we take
  out from the front the circles from the successor of &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; up to
  and including &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;, we let &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; be the new &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;, and we
  return to step 3.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If &lt;span class="math"&gt;\(C_i\)&lt;/span&gt; intersects a circle &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; that follows &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;, we take
  out from the front the circles from &lt;span class="math"&gt;\(C_n\)&lt;/span&gt; up to and including
  the predecessor of &lt;span class="math"&gt;\(C_j\)&lt;/span&gt;, we let &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; be the new &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;, and we
  return to step 3.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Our algorithm now works and will fill out the plane, beginning from
the starting point. But it does not detect where it should stop
because it has reached the boundary of the space we want to fill. To
achieve that, we have to do some more work. We will now make a
distinction between those circles of the front to which we can attach
a tangent circle without breaching the boundaries that have been set.
We will call these circles &lt;em&gt;alive&lt;/em&gt;. When a circle is inserted into the
front, it is alive. The algorithm then will further evolve to this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We add the first two circles (these two form a trivial front).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We want to insert the &lt;span class="math"&gt;\(i\)&lt;/span&gt;th circle. We find the circle in the front
   that is closest to our starting point. Suppose that this circle
   &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;. If there are more than one circles with the same distance,
   we pick the one that was inserted earliest.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We try to interpolate a circle between &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and its successor in
   the front, &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;. Let us call this circle &lt;span class="math"&gt;\(C_i\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If &lt;span class="math"&gt;\(C_i\)&lt;/span&gt; intersects a circle of the front:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If &lt;span class="math"&gt;\(C_i\)&lt;/span&gt; intersects a circle &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; that precedes &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;, we take
  out from the front and kill the circles from the successor of
  &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; up to and including &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;, we let &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; be the new &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;,
  and we return to step 3.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If &lt;span class="math"&gt;\(C_i\)&lt;/span&gt; intersects a circle &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; that follows &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;, we take
  out from the front and kill the circles from &lt;span class="math"&gt;\(C_n\)&lt;/span&gt; up to and
  including the predecessor of &lt;span class="math"&gt;\(C_j\)&lt;/span&gt;, we let &lt;span class="math"&gt;\(C_j\)&lt;/span&gt; be the new
  &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;, and we return to step 3.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;At this point we have found a circle &lt;span class="math"&gt;\(C_i\)&lt;/span&gt; that does not intersect
   any circle in the front. We then check whether it breaches the
   boundaries of our shape.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If it does, then the circle &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; that we picked in step 2
  cannot be used to add a circle tangent to it inside the
  boundaries of our shape, so we must go back and try to find a
  different &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;. We put back in the front any circles that we
  removed in step 4. We resurrect any circles that we may have
  killed in step 4, apart from those that we have found in step 2
  while trying to find the &lt;span class="math"&gt;\(i\)&lt;/span&gt;th circle. We kill &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and we
  return to step 2.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If it does not, we insert &lt;span class="math"&gt;\(C_i\)&lt;/span&gt; in the front and we return to
   step 2 to insert the next circle (&lt;span class="math"&gt;\(i \leftarrow i + 1\)&lt;/span&gt;),
   resurrecting all the circles in the front.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Steps 2&amp;ndash;5 are repeated until we have inserted the desired number of
circles or we cannot add a circle because there is no circle left
alive in the front.&lt;/p&gt;
&lt;p&gt;Let's delve a bit deeper in what is going on with circles that are
alive, dead, and resurrected. When we try to add a circle &lt;span class="math"&gt;\(C_i\)&lt;/span&gt; with a
given radius, we find the circle in the front, &lt;span class="math"&gt;\(C_m\)&lt;/span&gt;, that is closest
to our starting point. The tangent circle that we try to add can
intersect with the front, so we then need to adjust the front. The
circles we remove from the front are no longer alive. After doing
that, however, we may discover that our efforts have been in vain,
because the tangent circle hits the boundaries of our shape. Then we
should not have picked that &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; in the first place and we should not
have adjusted the front. Circle &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; must remain dead, as well as any
previous &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; circles that we may have tried in our effort to insert
&lt;span class="math"&gt;\(C_i\)&lt;/span&gt; in the shape; all other circles that we killed by adjusting the
front must be resurrected. When finally we do manage to insert &lt;span class="math"&gt;\(C_i\)&lt;/span&gt;
somewhere, we will continue to add circle &lt;span class="math"&gt;\(C_{i+1}\)&lt;/span&gt;; when we begin
our effort to insert a new circle, we must start fresh, by having all
the circles in the front alive.&lt;/p&gt;
&lt;p&gt;As for the resurrection itself, in reality this is but an
implementation of an undo functionality. When we undo our actions, we
reverse them from the most recent to the previous ones, going
backwards in time; that is, we use a Last In First Out (LIFO) logic.&lt;/p&gt;
&lt;h3&gt;Roundings&lt;/h3&gt;
&lt;p&gt;Let's take three circles with radii equal to &lt;span class="math"&gt;\(1\)&lt;/span&gt;, as in the following
figure. &lt;span class="math"&gt;\(C_1\)&lt;/span&gt; is centered at &lt;span class="math"&gt;\((0, 0)\)&lt;/span&gt;, &lt;span class="math"&gt;\(C_2\)&lt;/span&gt; at &lt;span class="math"&gt;\((2, 0)\)&lt;/span&gt;, and &lt;span class="math"&gt;\(C_3\)&lt;/span&gt; at
&lt;span class="math"&gt;\((1, \sqrt{3})\)&lt;/span&gt;; &lt;span class="math"&gt;\(C_3\)&lt;/span&gt; is tangent to &lt;span class="math"&gt;\(C_1\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_2\)&lt;/span&gt; and the
coordinates of its center can be found using the Pythagorean theorem.
What is the distance between the centers of &lt;span class="math"&gt;\(C_1\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_2\)&lt;/span&gt; and
between &lt;span class="math"&gt;\(C_1\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_3\)&lt;/span&gt;? Both distances are equal to &lt;span class="math"&gt;\(2\)&lt;/span&gt;, as all the
radii are equal. &lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/social-distancing/three_circles.png" width="300"&gt;&lt;/p&gt;
&lt;p&gt;Suppose now that from the coordinates of &lt;span class="math"&gt;\(C_1\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_3\)&lt;/span&gt; we want to
calculate anew the distance &lt;span class="math"&gt;\(C_1 C_3\)&lt;/span&gt;. Using the Pythagorean theorem
again, this distance will be equal to &lt;span class="math"&gt;\(\sqrt{(\sqrt{3})^2 + 1^2} = 2\)&lt;/span&gt;.
If, however, we carry out the calculation in our computer, we will
find that the result is &lt;span class="math"&gt;\(1.999\ldots &amp;lt; 2\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;This happens because real (floating point) numbers are stored in a
computer with a specific precision; therefore, irrational numbers are
not stored exactly and calculations involving irrational numbers will
produce different results than what we would expect from theory. In
this assignment, you should use roundings to avoid surprises:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Round the distance from the center of a circle to the starting
  point.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Once we calculate the coordinates of the center of a new circle,
  round the coordinates.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When you check whether two circles intersect, you must check whether
  the distance of their centres is greater than the sum of their
  radii. Round that distance before making the comparison.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Round the distance of a circle from a line segment.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Round the numbers to two decimal places. If you do that, your program
would find that in the previous figure, the distance &lt;span class="math"&gt;\(C_1 C_3\)&lt;/span&gt; is
equal to the distance &lt;span class="math"&gt;\(C_1 C_2\)&lt;/span&gt;. &lt;/p&gt;
&lt;p&gt;Having said that, rounding to two decimal places means losing
precision, so again your calculations may not be what theory would
predict. But at least you will know where any discrepancies come from.&lt;/p&gt;
&lt;h3&gt;Finding the Circle Closest to the Starting Point&lt;/h3&gt;
&lt;p&gt;If &lt;span class="math"&gt;\((x, y)\)&lt;/span&gt; are the coordinates of the starting point, then to find
the circle in the front that is closest to the starting point, we need
to find the distances of the centers of the front's circles to the
starting point. For every circle in the front with center at &lt;span class="math"&gt;\((m_x,
m_y)\)&lt;/span&gt;, the distance is:&lt;/p&gt;
&lt;div class="math"&gt;$$ d = \sqrt{(m_x - x)^2 + (m_y - y)^2} $$&lt;/div&gt;
&lt;p&gt;If &lt;span class="math"&gt;\((x, y) = (0, 0)\)&lt;/span&gt;, then we have:&lt;/p&gt;
&lt;div class="math"&gt;$$ d = \sqrt{m_{x}^2 + m_{y}^2} $$&lt;/div&gt;
&lt;p&gt;For simplicity we will be using &lt;span class="math"&gt;\((0, 0)\)&lt;/span&gt; as our starting point.&lt;/p&gt;
&lt;h3&gt;Finding a Circle Tangent to Two Other Circles&lt;/h3&gt;
&lt;p&gt;If we have two circles &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_n\)&lt;/span&gt; and we want to find a third
circle &lt;span class="math"&gt;\(C_k\)&lt;/span&gt;, wih radius &lt;span class="math"&gt;\(r\)&lt;/span&gt;, tangent to these two, as in the
following figure, we work as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/social-distancing/circles_tangent.png" width="400"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We calculate the horizontal distance &lt;span class="math"&gt;\(d_x\)&lt;/span&gt; and the vertical distance
  &lt;span class="math"&gt;\(d_y\)&lt;/span&gt; of the two circles &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;. If &lt;span class="math"&gt;\((m_x, m_y)\)&lt;/span&gt; is the
  center of &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and &lt;span class="math"&gt;\((n_x, n_y)\)&lt;/span&gt; is the center of &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;, we have:
  &lt;div class="math"&gt;$$d_x = n_x - m_x$$&lt;/div&gt;
&lt;div class="math"&gt;$$d_y = n_y - m_y $$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We calculate the distance between the centers of &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;;
  &lt;div class="math"&gt;$$ d = \sqrt{d{_x}^2+ d{_y}^2}$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If &lt;span class="math"&gt;\(r_m\)&lt;/span&gt; is the radius of &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and &lt;span class="math"&gt;\(r_n\)&lt;/span&gt; is the radius of &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;, we
  calculate:
  &lt;div class="math"&gt;$$r_1 = r_m + r $$&lt;/div&gt;
&lt;div class="math"&gt;$$r_2 = r_n + r $$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We find:
  &lt;div class="math"&gt;$$\lambda = \frac{r{_1}^2 - r{_2}^2 + d^2}{2 d^2}$$&lt;/div&gt;
&lt;div class="math"&gt;$$\varepsilon = \sqrt{\frac{r{_1}^2}{d^2} - \lambda^2}$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The center &lt;span class="math"&gt;\((k_x, k_y)\)&lt;/span&gt; of circle &lt;span class="math"&gt;\(C_k\)&lt;/span&gt; is:
   &lt;div class="math"&gt;$$k_x = m_x + \lambda d_x \mp \varepsilon d_y $$&lt;/div&gt;
&lt;div class="math"&gt;$$k_y = m_u + \lambda d_y \pm \varepsilon d_x $$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We observe that we have two centers. We will use the first of them
  (that is, &lt;span class="math"&gt;\(- \varepsilon d_y\)&lt;/span&gt; for &lt;span class="math"&gt;\(k_x\)&lt;/span&gt; and &lt;span class="math"&gt;\(+ \varepsilon d_x\)&lt;/span&gt;
  for &lt;span class="math"&gt;\(k_y\)&lt;/span&gt;). Then the circles will be added to our shape
  counter-clockwise, as in our examples.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we had a ruler and a compass, it would be easy to find the tangent
circles with a simple geometrical construction. In the figure you can
see that it suffices to find the intersection points &lt;span class="math"&gt;\(C_m\)&lt;/span&gt; and &lt;span class="math"&gt;\(C_n\)&lt;/span&gt;
with radii &lt;span class="math"&gt;\(r_m + r\)&lt;/span&gt; and &lt;span class="math"&gt;\(r_n + r\)&lt;/span&gt; respectively. The mathematical
formulas above are derived using vector analysis.&lt;/p&gt;
&lt;h3&gt;Distance of Circle from Line Segment&lt;/h3&gt;
&lt;p&gt;To find the distance of a circle from a line segment that lies between
two points &lt;span class="math"&gt;\(u\)&lt;/span&gt; and &lt;span class="math"&gt;\(v\)&lt;/span&gt;, we must first find the distance of the center
of the circle from the segment. If the circle's center has
coordinates, &lt;span class="math"&gt;\((c_x, c_y)\)&lt;/span&gt;, we go like this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We calculate the square of the distance between the two points:
  &lt;div class="math"&gt;$$ l_2 = (u_x - v_x)^2 + (u_y - v_y)^2$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If this distance is equal to zero, then the two endpoints of the
  segment coincide, therefore the distance from the center of the
  circle is simply:
  &lt;div class="math"&gt;$$d = \sqrt{(u_x - c_x)^2 + (u_y - c_y)^2}$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Otherwise, we calculate:
  &lt;div class="math"&gt;$$ t = \frac{(c_x - u_x) (v_x - u_x) + (c_y - u_y) (v_y - u_y)}{l_2}$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We make sure that &lt;span class="math"&gt;\(t\)&lt;/span&gt; is between &lt;span class="math"&gt;\(0\)&lt;/span&gt; and &lt;span class="math"&gt;\(1\)&lt;/span&gt;:
  &lt;div class="math"&gt;$$t = \max(0, \min(1, t))$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We find the projection &lt;span class="math"&gt;\(p\)&lt;/span&gt; of the center of the circle on the line
  segment:
  &lt;div class="math"&gt;$$ p_x = u_x + t (v_x - u_x) $$&lt;/div&gt;
&lt;div class="math"&gt;$$ p_y = u_y + t (v_y - u_y) $$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The distance of the center from the segment is:
  &lt;div class="math"&gt;$$d = \sqrt{(p_x - c_x)^2 + (p_y - c_y)^2}$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The above hold beause if we have two points &lt;span class="math"&gt;\(u\)&lt;/span&gt; and &lt;span class="math"&gt;\(v\)&lt;/span&gt;, the straight
line passing through these two points is given by the parametric
equations:&lt;/p&gt;
&lt;div class="math"&gt;$$ x = u_x + t(v_x - u_x) $$&lt;/div&gt;
&lt;div class="math"&gt;$$ y = u_y + t(v_y - u_y) $$&lt;/div&gt;
&lt;p&gt;The projection of a point &lt;span class="math"&gt;\(p\)&lt;/span&gt; on the line uses the initial value of
&lt;span class="math"&gt;\(t\)&lt;/span&gt;. However, the projection may lie beyond the limits of the line
segment, as you can see in the following figure. The projection of the
centre of left circle falls to the left of the segment, so we take the
distance of the centre from &lt;span class="math"&gt;\(u\)&lt;/span&gt; by using &lt;span class="math"&gt;\(t = 0\)&lt;/span&gt;. The projection of
the centre of the middle circle falls inside the segment so no
adjustment of &lt;span class="math"&gt;\(t\)&lt;/span&gt; is needed. In way symmetric to the left circle, the
projection of the center of the right circle lies to the right of the
segment, so we take the distance of the centre from &lt;span class="math"&gt;\(v\)&lt;/span&gt; by using &lt;span class="math"&gt;\(t =
1\)&lt;/span&gt;. Then, we calculate the distance of the centre of the circle
from the projection.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/social-distancing/distance_circle_segment.png" width="700"&gt;&lt;/p&gt;
&lt;p&gt;Having found the distance of the circle's center from the line
segment, to find the distance of the circle from the segment we
subtract the circle's radius. Or, to find whether the circle
intersects the segment, we compare the distance from the centre with
the radius.&lt;/p&gt;
&lt;h3&gt;Requirements&lt;/h3&gt;
&lt;p&gt;You will write a program called &lt;code&gt;social-distancing.py&lt;/code&gt;. You may use
the standard Python libraries &lt;code&gt;math&lt;/code&gt;, &lt;code&gt;random&lt;/code&gt;, &lt;code&gt;argparse&lt;/code&gt;, and &lt;code&gt;sys&lt;/code&gt;,
but not any others. Your program will be called as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python social_distancing.py &lt;span class="o"&gt;[&lt;/span&gt;-items ITEMS&lt;span class="o"&gt;]&lt;/span&gt; 
                            &lt;span class="o"&gt;[&lt;/span&gt;-r RADIUS&lt;span class="o"&gt;]&lt;/span&gt;
                            &lt;span class="o"&gt;[&lt;/span&gt;--min_radius MIN_RADIUS&lt;span class="o"&gt;]&lt;/span&gt;
                            &lt;span class="o"&gt;[&lt;/span&gt;--max_radius MAX_RADIUS&lt;span class="o"&gt;]&lt;/span&gt; 
                            &lt;span class="o"&gt;[&lt;/span&gt;-b BOUNDARY_FILE&lt;span class="o"&gt;]&lt;/span&gt; 
                            &lt;span class="o"&gt;[&lt;/span&gt;-s SEED&lt;span class="o"&gt;]&lt;/span&gt;
                            output_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The meaning of the program arguments is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-i ITEMS&lt;/code&gt;, &lt;code&gt;--items ITEMS&lt;/code&gt;: the number of items (circles) that we
  want to insert. If given, the program will try (but may not be able
  to) insert that many circles.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-r RADIUS&lt;/code&gt;, &lt;code&gt;--radius RADIUS&lt;/code&gt;: the circles radii. If given, all
  circles will have the same radius.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--min_radius MIN_RADIUS&lt;/code&gt;: the minimum radius. If given, circles
  will have random radii not smaller than &lt;code&gt;MIN_RADIUS&lt;/code&gt;. 
  This argument must be used with &lt;code&gt;--max_radius&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--max_radius MAX_RADIUS:&lt;/code&gt;: the maximum radius. If given, circles
  will have random sizes no bigger than &lt;code&gt;MAX_RADIUS&lt;/code&gt;. This argument
  must be used with &lt;code&gt;--min_radius&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-b BOUNDARY_FILE&lt;/code&gt;, &lt;code&gt;--boundary_file BOUNDARY_FILE&lt;/code&gt;: the boundaries
  of the shape we want to fill. If given, the program will try to
  place the circles inside the given shape.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-s SEED&lt;/code&gt;, &lt;code&gt;--seed SEED&lt;/code&gt;: if given the seed for the pseudo-random
  genereation; you should use &lt;code&gt;random.seed(SEED)&lt;/code&gt; at the beginning of
  your program.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;output_file&lt;/code&gt;: the file where the results of the program will be
  stored; this is a mandatory argument.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When the program finishes, it will print on its output an integer
number, the number of circles it managed to insert. The circles
themselves will be saved in &lt;code&gt;output_file&lt;/code&gt;, one in each line, in the
following format:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;x y r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That is, each line contains three real numbers, the &lt;span class="math"&gt;\(x\)&lt;/span&gt; coordinate of
the circle's center, the &lt;span class="math"&gt;\(y\)&lt;/span&gt; coordinate of the circle's center and its
radius &lt;span class="math"&gt;\(r\)&lt;/span&gt;. The numbers must be given with two decimal places.&lt;/p&gt;
&lt;p&gt;If boundaries are given through &lt;code&gt;-b BOUNDARY_FILE&lt;/code&gt;, the value of
&lt;code&gt;BOUNDARY_FILE&lt;/code&gt; will be the name of a file that specifies the borders.
The file will contain lines of the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;x1 y1 x2 y2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That is, each line will contain two coordinate pairs defining a line
segment. Your program will then include these lines, in the order they
are read, at the end of &lt;code&gt;output_file&lt;/code&gt;, after the produced circles.&lt;/p&gt;
&lt;p&gt;To visualize your results, you may use the following programs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="svg_draw.py"&gt;&lt;code&gt;svg_draw.py&lt;/code&gt;&lt;/a&gt;&lt;br/&gt;
    which you call with:&lt;br/&gt;
    &lt;code&gt;bash
    python svg_draw.py input_file output_file&lt;/code&gt;
    &lt;br/&gt; 
    where &lt;code&gt;input_file&lt;/code&gt; is the output file of your program and
    &lt;code&gt;output_file&lt;/code&gt; will be an SVG file. You will need to install the 
    &lt;a href="https://github.com/mozman/svgwrite"&gt;&lt;code&gt;svgwrite&lt;/code&gt;&lt;/a&gt; library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="mpl_draw.py"&gt;&lt;code&gt;mpl_draw.py&lt;/code&gt;&lt;/a&gt;&lt;br/&gt;
    which you call with:&lt;br/&gt;
    &lt;code&gt;bash
    python mpl_draw.py input_file output_file&lt;/code&gt;
    &lt;br/&gt; 
    where &lt;code&gt;input_file&lt;/code&gt; is the output file of your program and
    &lt;code&gt;output_file&lt;/code&gt; is a file whose type is determined by its suffix.
    For example, if you specify &lt;code&gt;myfile.png&lt;/code&gt; as &lt;code&gt;output_file&lt;/code&gt; you will
    get a PNG image; if you specify &lt;code&gt;myfile.svg&lt;/code&gt; you will get an SVG
    image; if you specify &lt;code&gt;myfile.pdf&lt;/code&gt; you will get a PDF image, and
    so on. You will need to install the
    &lt;a href="https://matplotlib.org/"&gt;&lt;code&gt;matplotlib&lt;/code&gt;&lt;/a&gt; library.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Examples&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Example 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python social_distancing.py -i &lt;span class="m"&gt;11&lt;/span&gt; -r &lt;span class="m"&gt;10&lt;/span&gt; circles_equal_11.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then the program will print &lt;code&gt;11&lt;/code&gt; and it will store its results in file 
&lt;a href="circles_equal_11.txt"&gt;&lt;code&gt;circles_equal_11.txt&lt;/code&gt;&lt;/a&gt;.
This file corresponds to the second figure we have seen above.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python social_distancing.py -i &lt;span class="m"&gt;1000&lt;/span&gt; -r &lt;span class="m"&gt;10&lt;/span&gt; circles_equal_1000.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then the program will print &lt;code&gt;1000&lt;/code&gt; and will store its results in file 
&lt;a href="circles_equal_1000.txt"&gt;&lt;code&gt;circles_equal_1000.txt&lt;/code&gt;&lt;/a&gt;. You can see the
circles in the figure below, along with the front; the last circle is
painted orange (on the right, a bit below the middle).&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/social-distancing/circles_equal_1000.png" width="700"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python social_distancing.py -i &lt;span class="m"&gt;200&lt;/span&gt; -r &lt;span class="m"&gt;10&lt;/span&gt; -b rectangle.txt &lt;span class="se"&gt;\&lt;/span&gt;
  circles_rectangle_equal.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then the program will use &lt;a href="rectangle.txt"&gt;&lt;code&gt;rectangle.txt&lt;/code&gt;&lt;/a&gt; to define
the boundaries, it will print &lt;code&gt;159&lt;/code&gt; and it will store its results in
&lt;a href="circles_rectangle_equal.txt"&gt;&lt;code&gt;circles_rectangle_equal.txt&lt;/code&gt;&lt;/a&gt;. You can
see the circles below.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/social-distancing/circles_rectangle_equal.png" width="400"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python social_distancing.py -i &lt;span class="m"&gt;1000&lt;/span&gt; --seed &lt;span class="m"&gt;13&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  --min_radius &lt;span class="m"&gt;5&lt;/span&gt; --max_radius &lt;span class="m"&gt;10&lt;/span&gt; circles_random_1000.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;then the program will print &lt;code&gt;1000&lt;/code&gt; and it will store its results in 
&lt;a href="circles_random_1000.txt"&gt;&lt;code&gt;circles_random_1000.txt&lt;/code&gt;&lt;/a&gt;. You can see the
corresponding image below.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/social-distancing/circles_random_1000.png" width="700"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example 5&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you invoke the program with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python social_distancing.py --seed &lt;span class="m"&gt;42&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  --min_radius &lt;span class="m"&gt;5&lt;/span&gt; --max_radius &lt;span class="m"&gt;10&lt;/span&gt; -b square_holes.txt &lt;span class="se"&gt;\&lt;/span&gt;
  square_holes_random.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Then the program will use 
&lt;a href="square_holes.txt"&gt;&lt;code&gt;square_holes.txt&lt;/code&gt;&lt;/a&gt; to define the boundaries, it
will print &lt;code&gt;584&lt;/code&gt; and it will store its results in 
&lt;a href="square_holes_random.txt"&gt;&lt;code&gt;square_holes_random.txt&lt;/code&gt;&lt;/a&gt;. This file
corresponds to the following figure.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/social-distancing/square_holes_random.png" width="700"&gt;&lt;/p&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The proof for the formulas for finding tangent circles is in 1.12.2
  and 3.12.2 of &lt;a href='#vince:2005' id='ref-vince:2005-1'&gt;[1]&lt;/a&gt;. The proof for finding the distance of a
  point from a line segment comes from 1.11.12 και 3.11.10 of the same
  book and &lt;a href="https://stackoverflow.com/a/1501725"&gt;https://stackoverflow.com/a/1501725&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The algorithm described in the assignment for filling the plane
  without boundaries was published in &lt;a href='#wang:2006' id='ref-wang:2006-1'&gt;[2]&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The problem is a special case of &lt;em&gt;circle packing&lt;/em&gt;, which has
  attracted the attention of mathematicians for centuries. You can
  find some details at the &lt;a href="https://en.wikipedia.org/wiki/Circle_packing"&gt;Wikipedia
  article&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The modified algorithm for filling the circles in a defined shape is
  not designed to be optimal; however, it differs from simple circle
  packing because it is an &lt;em&gt;online algorithm&lt;/em&gt;. It tries to pack as
  many circles as possible in a given space, while having to place
  each circle as it comes, and without having the opportunity to move
  a set circle to another place. It therefore solves social distancing
  when we have to place people as they come, people may have different
  space requirements around them, and we cannot move people once we
  have put them in their position.&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;hr&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;div class='bibliography'&gt;&lt;ol&gt;&lt;li id='vince:2005'&gt;John Vince.
&lt;em&gt;Geometry for Computer Graphics: Formulae, Examples &amp;amp; Proofs&lt;/em&gt;.
Springer, 2005. &lt;a class="cite-backref" href="#ref-vince:2005-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='wang:2006'&gt;Weixin Wang, Hui Wang, Guozhong Dai, and Hongan Wang.
Visualization of large hierarchical data by circle packing.
In &lt;em&gt;Proceedings of the SIGCHI Conference on Human Factors in Computing Systems&lt;/em&gt;, CHI ’06, 517–520. New York, NY, USA, 2006. Association for Computing Machinery.
URL: &lt;a href="https://doi.org/10.1145/1124772.1124851"&gt;https://doi.org/10.1145/1124772.1124851&lt;/a&gt;, &lt;a href="https://doi.org/10.1145/1124772.1124851"&gt;doi:10.1145/1124772.1124851&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-wang:2006-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><category term="assignments"></category></entry><entry><title>Perfect Strangers</title><link href="https://louridas.github.io/assignments/perfect-strangers/" rel="alternate"></link><published>2017-09-18T00:00:00+03:00</published><updated>2017-09-18T00:00:00+03:00</updated><author><name>Panos Louridas</name></author><id>tag:louridas.github.io,2017-09-18:/assignments/perfect-strangers/</id><summary type="html">&lt;p&gt;Sometimes we want to break apart a set of entities to subsets such
that the entities in each subset have no relationship between them. If
we use a graph to represent the entities and their relationships, the
problem we have to solve is to find subsets of the graph so …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Sometimes we want to break apart a set of entities to subsets such
that the entities in each subset have no relationship between them. If
we use a graph to represent the entities and their relationships, the
problem we have to solve is to find subsets of the graph so that the
members of each subset are not neighbours with any other member of the
same subset. This is an instance of an
&lt;a href="https://en.wikipedia.org/wiki/Independent_set_(graph_theory)"&gt;independent set&lt;/a&gt;:
a set of nodes such that no node is a neighbour of any other node in
the set. An independent set is called a
&lt;a href="https://en.wikipedia.org/wiki/Maximal_independent_set"&gt;maximal independent set&lt;/a&gt;
when it is not a subset of any other independent set. In other words,
there is no node outside the set that can be added to the set with the
set remaining independent.&lt;/p&gt;
&lt;p&gt;Below you can see the two maximal independent sets of a star graph:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/perfect-strangers/star_1.png" width="300"&gt;
&lt;img src="https://louridas.github.io/assignments/perfect-strangers/star_2.png" width="300"&gt;&lt;/p&gt;
&lt;p&gt;Similarly, below you can see the six maximal independent sets of a
cube graph:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/perfect-strangers/cube_1.png" width="300"&gt;
&lt;img src="https://louridas.github.io/assignments/perfect-strangers/cube_2.png" width="300"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/perfect-strangers/cube_3.png" width="300"&gt;
&lt;img src="https://louridas.github.io/assignments/perfect-strangers/cube_4.png" width="300"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/perfect-strangers/cube_5.png" width="300"&gt;
&lt;img src="https://louridas.github.io/assignments/perfect-strangers/cube_6.png" width="300"&gt;&lt;/p&gt;
&lt;p&gt;Finally, here are four maximal independent sets of the
&lt;a href="https://en.wikipedia.org/wiki/Petersen_graph"&gt;Petersen graph&lt;/a&gt; (there
are more):&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/perfect-strangers/petersen_1.png" width="300"&gt;
&lt;img src="https://louridas.github.io/assignments/perfect-strangers/petersen_2.png" width="300"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/perfect-strangers/petersen_3.png" width="300"&gt;
&lt;img src="https://louridas.github.io/assignments/perfect-strangers/petersen_4.png" width="300"&gt;&lt;/p&gt;
&lt;p&gt;In this assignment you will implement a program that finds the maximal
independent subsets of a graph.&lt;/p&gt;
&lt;h2&gt;Requirements&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;You will write a program called &lt;code&gt;mis.py&lt;/code&gt; that finds the maximal
   independent subsets of a graph using the algorithm of Johnson,
   Yannakakis and Papadimitriou, described in &lt;a href='#johnson:1988' id='ref-johnson:1988-1'&gt;[1]&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You can use the &lt;a href="https://networkx.github.io/"&gt;networkx&lt;/a&gt; library for
   graph input, output, manipulation, and drawing.&lt;/li&gt;
&lt;li&gt;You can use anything you want from the
   &lt;a href="https://docs.python.org/3/library/"&gt;Python library&lt;/a&gt;. &lt;/li&gt;
&lt;li&gt;The program must be called as follows:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python mis.py &lt;span class="o"&gt;[&lt;/span&gt;-h&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-d&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-n NAME&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-f FIGURE&lt;span class="o"&gt;]&lt;/span&gt; input
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;input&lt;/code&gt; parameter corresponds to the name of the file containing
the graph. The file will contain the graph in
&lt;a href="https://networkx.github.io/documentation/stable/reference/readwrite.adjlist.html"&gt;networkx adjacency list format&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If the user provides the parameter &lt;code&gt;-d&lt;/code&gt;, the program will display on
screen the graph and each maximal independent subset, similarly to the
way we have presented them here. The actual images produced need not
be exactly the same as the one we have shown, as graph layout depends
on many parameters.&lt;/p&gt;
&lt;p&gt;If the user provides the parameter &lt;code&gt;-n NAME&lt;/code&gt; and &lt;code&gt;-f FIGURE&lt;/code&gt; each
images will be stored in a file with name &lt;code&gt;NAME_x.FIGURE&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt;
is a positive number. For example, if the user enters &lt;code&gt;-n cube -f
png&lt;/code&gt;, the program will store the images in the files &lt;code&gt;cube_1.png&lt;/code&gt;,
&lt;code&gt;cube_2.png&lt;/code&gt;, and so on.&lt;/p&gt;
&lt;p&gt;The parameter &lt;code&gt;-h&lt;/code&gt; can be used to display a short description of the
program and its parameters.&lt;/p&gt;
&lt;p&gt;In all cases, the program output will be the maximal independend
subsets in lexicographic order. So, if we are dealing with the star
graph, the output will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[&amp;#39;0&amp;#39;]
[&amp;#39;1&amp;#39;, &amp;#39;10&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;6&amp;#39;, &amp;#39;7&amp;#39;, &amp;#39;8&amp;#39;, &amp;#39;9&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;While if we are dealing with the cube graph, the output will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[&amp;#39;(0, 0, 0)&amp;#39;, &amp;#39;(0, 1, 1)&amp;#39;, &amp;#39;(1, 0, 1)&amp;#39;, &amp;#39;(1, 1, 0)&amp;#39;]
[&amp;#39;(0, 0, 0)&amp;#39;, &amp;#39;(1, 1, 1)&amp;#39;]
[&amp;#39;(0, 0, 1)&amp;#39;, &amp;#39;(0, 1, 0)&amp;#39;, &amp;#39;(1, 0, 0)&amp;#39;, &amp;#39;(1, 1, 1)&amp;#39;]
[&amp;#39;(0, 0, 1)&amp;#39;, &amp;#39;(1, 1, 0)&amp;#39;]
[&amp;#39;(0, 1, 0)&amp;#39;, &amp;#39;(1, 0, 1)&amp;#39;]
[&amp;#39;(0, 1, 1)&amp;#39;, &amp;#39;(1, 0, 0)&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Graph Examples&lt;/h2&gt;
&lt;p&gt;You can check your program with the following files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://louridas.github.io/assignments/perfect-strangers/star_graph_10.txt"&gt;Star graph with 10 nodes&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://louridas.github.io/assignments/perfect-strangers/cube_graph.txt"&gt;Cube graph&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://louridas.github.io/assignments/perfect-strangers/petersen_graph.txt"&gt;Petersen graph&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://louridas.github.io/assignments/perfect-strangers/barabasi_albert_graph_15.txt"&gt;Barabási-Albert graph with 15 nodes&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://louridas.github.io/assignments/perfect-strangers/powerlaw_cluster_graph_20.txt"&gt;Powerlaw cluster graph with 20 nodes&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://louridas.github.io/assignments/perfect-strangers/erdos_renyi_graph_20.txt"&gt;Erdős-Rényi graph with 20 nodes&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://louridas.github.io/assignments/perfect-strangers/erdos_renyi_graph_25.txt"&gt;Erdős-Rényi graph with 25 nodes&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;hr&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;div class='bibliography'&gt;&lt;ol&gt;&lt;li id='johnson:1988'&gt;David&amp;nbsp;S. Johnson, Mihalis Yannakakis, and Christos&amp;nbsp;H. Papadimitriou.
On generating all maximal independent sets.
&lt;em&gt;Information Processing Letters&lt;/em&gt;, 27(3):119–123, March 1988. &lt;a class="cite-backref" href="#ref-johnson:1988-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><category term="assignments"></category></entry><entry><title>A Kilo of Data</title><link href="https://louridas.github.io/assignments/a-kilo-of-data/" rel="alternate"></link><published>2017-08-07T00:00:00+03:00</published><updated>2017-08-07T00:00:00+03:00</updated><author><name>Panos Louridas</name></author><id>tag:louridas.github.io,2017-08-07:/assignments/a-kilo-of-data/</id><summary type="html">&lt;p&gt;The amount of data produced in the world is increasing rapidly, and so
does the storage needed to accommodate all that data. Data centers can
be bigger than football fields and require electrical power enough to
power a whole city.&lt;/p&gt;
&lt;p&gt;Scientists are trying to find more and more efficient storage …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The amount of data produced in the world is increasing rapidly, and so
does the storage needed to accommodate all that data. Data centers can
be bigger than football fields and require electrical power enough to
power a whole city.&lt;/p&gt;
&lt;p&gt;Scientists are trying to find more and more efficient storage media;
one approach of particular interest is to use DNA for storage. With
the right encoding, one cubic centimeter of DNA can store &lt;span class="math"&gt;\(10^{16}\)&lt;/span&gt; bits
of data, which means that we could store all the data in the world in
a kilo of DNA.&lt;/p&gt;
&lt;p&gt;But which is the right encoding? One way to go is the following.
Suppose we want to encode a file in DNA:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We take the file contents and we encode them using &lt;em&gt;base three&lt;/em&gt;
  Huffman coding. In normal Huffman coding, we encode our data
  using bits, that is, 0 and 1. In base three Huffman coding
  we encode our data using &lt;em&gt;trits&lt;/em&gt;, that is, 0, 1, and 2.&lt;/li&gt;
&lt;li&gt;Base three Huffman coding works exactly like base two Huffman
  coding, but when we work with the priority queue, instead of
  taking out two elements and inserting one, we take out three
  elements and insert one.&lt;/li&gt;
&lt;li&gt;In this way we create a tree, which is triadic. Its branches
  correspond to 0, 1, and 2, instead of only 0 and 1. The Huffman
  coding results again from the paths from the root to the leaves of
  the tree.&lt;/li&gt;
&lt;li&gt;We must be careful if our file does not have an odd number of
  characters. As each time we modify the priority queue we take out
  three items and we insert one, its size is reduced by two.
  Therefore, if the file does not have an odd number of characters, we
  must add a virtual character that occurs zero times.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After encoding our file in base three Huffman code, we go on to encode
the four DNA bases, A (adenine), C (cytocine), G (guanine), T
(thymine). To do that, we read the encoded file trit by trit and
produce DNA bases according to the following table:&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;previous base&lt;/th&gt;
    &lt;th colspan="3"&gt;current trit&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;0&lt;/td&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;2&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;A&lt;/td&gt;
    &lt;td&gt;C&lt;/td&gt;
    &lt;td&gt;G&lt;/td&gt;
    &lt;td&gt;T&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;C&lt;/td&gt;
    &lt;td&gt;G&lt;/td&gt;
    &lt;td&gt;T&lt;/td&gt;
    &lt;td&gt;A&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;G&lt;/td&gt;
    &lt;td&gt;T&lt;/td&gt;
    &lt;td&gt;A&lt;/td&gt;
    &lt;td&gt;C&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;T&lt;/td&gt;
    &lt;td&gt;A&lt;/td&gt;
    &lt;td&gt;C&lt;/td&gt;
    &lt;td&gt;G&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;To use this table we work as follows. If we want to encode trit 2 and
the previous trip that we encoded in DNA was encoded using base G,
then the 2 will be encoded with base C; and so on. For the first trit,
for which we have no previous one, we assume that we there was a
previous virtual trit that was encoded with base A.&lt;/p&gt;
&lt;p&gt;For example, if we want to encode a file that contains the phrase
"hello, world" with a base three Huffman encoding, we will get the
following tree:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/a-kilo-of-data/hello_world.png" width="700"&gt;&lt;/p&gt;
&lt;p&gt;Note that the file ends in a newline character (&lt;code&gt;\n&lt;/code&gt;), which is also
encoded. Moreover, the file has an odd number of characters, so we
have added a virtual character, which we denote by &amp;Oslash;. In
practice this can be simply the empty character, &lt;code&gt;''&lt;/code&gt;, which is really
nothing&amp;mdash;but of course it should not be the space character &lt;code&gt;'
'&lt;/code&gt;; we use the symbol &amp;#9251; for that. The tree is essentially the
following correspondence table:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Letter&lt;/th&gt;
&lt;th&gt;Encoding&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;02&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;Oslash;&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;201&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;#9251;&lt;/td&gt;
&lt;td&gt;202&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;,&lt;/td&gt;
&lt;td&gt;220&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;221&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;222&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;With this encoding, the file with "hello, world" in it is
represented as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0022211212202020221011221201
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now, working with the table of mappings between trits and DNA bases,
the &lt;code&gt;0&lt;/code&gt; will become &lt;code&gt;C&lt;/code&gt;, the second &lt;code&gt;0&lt;/code&gt; will become &lt;code&gt;G&lt;/code&gt;, the &lt;code&gt;2&lt;/code&gt; will
become &lt;code&gt;C&lt;/code&gt;, and so on. At the end we will end up with the DNA
sequence:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;CGCATCTGATGTGTGTGCTAGATGATAG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To decode this DNA sequence, we work in exactly the opposite way. We
take the bases one by one and we convert them to trits using the
following table:&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;previous base&lt;/th&gt;
    &lt;th colspan="4"&gt;current base&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;A&lt;/td&gt;
    &lt;td&gt;C&lt;/td&gt;
    &lt;td&gt;G&lt;/td&gt;
    &lt;td&gt;T&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;A&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;0&lt;/td&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;2&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;C&lt;/td&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;0&lt;/td&gt;
    &lt;td&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;G&lt;/td&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;T&lt;/td&gt;
    &lt;td&gt;0&lt;/td&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;The table is used as the one during encoding. In the beginning we
assume that the previous base is &lt;code&gt;A&lt;/code&gt;. In our example, we then take
base &lt;code&gt;C&lt;/code&gt;, which is encoded to &lt;code&gt;0&lt;/code&gt;. Following that, we take base &lt;code&gt;G&lt;/code&gt;;
this time the previous page is &lt;code&gt;C&lt;/code&gt;, so &lt;code&gt;G&lt;/code&gt; is encoded using &lt;code&gt;0&lt;/code&gt;; and
so on.&lt;/p&gt;
&lt;p&gt;After getting the corresponding trits, we convert them to the original
file contents using the base three Huffman code that we have
created. That means that &lt;code&gt;00&lt;/code&gt; is converted back to &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;222&lt;/code&gt; is
converted back to &lt;code&gt;e&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;The purpose of this assignment is to implement a DNA encoding and
decoding scheme; for more details on the underlying research, see
&lt;a href='#extance:2016' id='ref-extance:2016-1'&gt;[1]&lt;/a&gt; and &lt;a href='#goldman:2013' id='ref-goldman:2013-1'&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Requirements&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;You will write a program called &lt;code&gt;dna_store.py&lt;/code&gt; to implement the DNA
   storage scheme we described.&lt;/li&gt;
&lt;li&gt;You will implement your own prioriry queue for use in the program.&lt;/li&gt;
&lt;li&gt;Your program must be called as follows:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python dna_store.py &lt;span class="o"&gt;[&lt;/span&gt;-d&lt;span class="o"&gt;]&lt;/span&gt; input output huffman
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If the user does not give the parameter &lt;code&gt;-d&lt;/code&gt;, the program will read
the file given in the &lt;code&gt;input&lt;/code&gt; parameter (that does not mean that the
file is actually called &lt;code&gt;input&lt;/code&gt;, that is just a stand-in), it will
store the DNA encoding in the file given by the &lt;code&gt;output&lt;/code&gt; parameter,
and will save the Huffman code in the file given by the &lt;code&gt;huffman&lt;/code&gt;
parameter. The Huffman encoding will be stored in a
&lt;a href="https://en.wikipedia.org/wiki/Comma-separated_values"&gt;Comma Separated Values (CSV)&lt;/a&gt;
file. To work with such files you should use the
&lt;a href="https://docs.python.org/3/library/csv.html"&gt;Python &lt;code&gt;csv&lt;/code&gt; library&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If the user gives the parameter &lt;code&gt;-d&lt;/code&gt;, the program will read the file
given by the &lt;code&gt;input&lt;/code&gt; parameter, will decode it using the Huffman code
given by the &lt;code&gt;huffman&lt;/code&gt; parameter, and will store the decoded result to
the file given by the &lt;code&gt;output&lt;/code&gt; parameter. Remember that a file can
only be decoded correctly with the Huffman code that was used for
its encoding.&lt;/p&gt;
&lt;h3&gt;Examples&lt;/h3&gt;
&lt;p&gt;If the user gives:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python dna_store.py hello_world.txt hello_world_dna.txt hello_world_huffman.csv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;using the file &lt;a href="https://louridas.github.io/assignments/a-kilo-of-data/hello_world.txt"&gt;hello_world.txt&lt;/a&gt;, then the
Huffman code will be stored in the file
&lt;a href="https://louridas.github.io/assignments/a-kilo-of-data/hello_world_huffman.csv"&gt;hello_world_huffman.csv&lt;/a&gt; and the
encoded file will be
&lt;a href="https://louridas.github.io/assignments/a-kilo-of-data/hello_world_dna.txt"&gt;hello_world_dna.txt&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If the user gives:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python dna_store.py &lt;span class="m"&gt;1984&lt;/span&gt;.txt 1984_dna.txt 1984_huffman.csv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;with the file &lt;a href="https://louridas.github.io/assignments/a-kilo-of-data/1984.txt"&gt;1984.txt&lt;/a&gt;, then the Huffman code
will be stored in the file
&lt;a href="https://louridas.github.io/assignments/a-kilo-of-data/1984_huffman.csv"&gt;1984_huffman.csv&lt;/a&gt; and the encoded file will
be &lt;a href="https://louridas.github.io/assignments/a-kilo-of-data/1984_dna.txt"&gt;1984_dna.txt&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If the user gives:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python dna_store.py -d 1984_dna.txt 1984_decoded.txt 1984_huffman.csv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;the file &lt;code&gt;1984_decoded.txt&lt;/code&gt; must be exactly the same as the file
&lt;code&gt;1984.txt&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Notes on Implementation&lt;/h3&gt;
&lt;p&gt;Depending on how you implement the priority queue and the Huffman
encoding, the results may differ from the ones shown above. That is fine.
In any case, you can check that your program is correct by verifying
that the decoding of an encoded file is the original file.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;hr&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;div class='bibliography'&gt;&lt;ol&gt;&lt;li id='extance:2016'&gt;Andy Extance.
How &lt;span class="bibtex-protected"&gt;DNA&lt;/span&gt; could store all the world's data.
&lt;em&gt;Nature&lt;/em&gt;, 537(7618):22–14, August 31 2016. &lt;a class="cite-backref" href="#ref-extance:2016-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='goldman:2013'&gt;Nick Goldman, Paul Bertone, Chen, Siyuan, Dessimoz, Christophe, LeProust, Emily&amp;nbsp;M., Sipos, Botond, and Ewan Birney.
Towards practical, high-capacity, low-maintenance information storage in synthesized &lt;span class="bibtex-protected"&gt;DNA&lt;/span&gt;.
&lt;em&gt;Nature&lt;/em&gt;, 494(7435):77–80, February 3 2013. &lt;a class="cite-backref" href="#ref-goldman:2013-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><category term="assignments"></category></entry><entry><title>Genome Assembly</title><link href="https://louridas.github.io/assignments/genome-assembly/" rel="alternate"></link><published>2017-08-02T00:00:00+03:00</published><updated>2017-08-02T00:00:00+03:00</updated><author><name>Panos Louridas</name></author><id>tag:louridas.github.io,2017-08-02:/assignments/genome-assembly/</id><summary type="html">&lt;p&gt;One of the most important scientific developments of the last decades
has been the decoding of the human genome. Thanks to the techniques
that were developed in that effort, we can now investigate genetic
diseases, detect mutations, study genomes of extinct species, among
other fascinating applications.&lt;/p&gt;
&lt;p&gt;Genomes are encoded in …&lt;/p&gt;</summary><content type="html">&lt;p&gt;One of the most important scientific developments of the last decades
has been the decoding of the human genome. Thanks to the techniques
that were developed in that effort, we can now investigate genetic
diseases, detect mutations, study genomes of extinct species, among
other fascinating applications.&lt;/p&gt;
&lt;p&gt;Genomes are encoded in the DNA, a large organic molecule that is
composed of a double helix. The double helix is made up of four bases:
cytosine (C), guanine (G), adenine (A), and thymine (T). Each part of
the double helix is constructed from a series of bases, like
ACCGTATAG. The other part of the double helix is constructed from
bases that are connected with their corresponding bases on the first
part, according to the rules A-T, C-G. So, if one part of the helix is
ACCGTATAG, the other part will be TGGCATATC.&lt;/p&gt;
&lt;p&gt;In order to find the composition of an unknown DNA piece, we work as
follows. We create many copies of the chain and we break them up into
little fragments, for instance, fragments containing three bases each.
Using specialized instruments we can identify such small fragments
easily. In this way we end up with a set of known fragments. We are
then left with the problem of assembling the fragments to a DNA
sequence, whose composition we will then know.&lt;/p&gt;
&lt;p&gt;Suppose then that we have the following fragments, or &lt;em&gt;polymers&lt;/em&gt; as
they are known: GTG, TGG, ATG, GGC, GCG, CGT, GCA, TGC, CAA, AAT. Each
one of them has length 3, but in general they can have length &lt;span class="math"&gt;\(k\)&lt;/span&gt;. To
find the DNA sequence from which they were broken up, we create a
graph. In that graph, the vertices are polymers of length 2 (or, more
generally, &lt;span class="math"&gt;\(k - 1\)&lt;/span&gt;) that are derived from the polymers of length 3
(or, &lt;span class="math"&gt;\(k\)&lt;/span&gt; in the general case), taking for each polymer of length 3
(&lt;span class="math"&gt;\(k\)&lt;/span&gt;) the first 2 (&lt;span class="math"&gt;\(k - 1\)&lt;/span&gt;) and the last 2 (&lt;span class="math"&gt;\(k - 1\)&lt;/span&gt;) polymers. So,
from GTG we will get GT and TG, from TGG we will get TG and GG. In the
graph we add one edge for every one of the initial polymers or length
3 (&lt;span class="math"&gt;\(k\)&lt;/span&gt;) that was used to derive the two vertices. We give the name of
the polymer to that edge. So, from ATG we got vertices AT and TG and
the edge ATG. You can see the graph that results from our example:&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="https://louridas.github.io/assignments/genome-assembly/fragment_graph.png" width="400"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;To find the initial DNA sequence we only need to find a path in the
graph that visits all edges exactly once. We call a path with this
property &lt;a href="https://en.wikipedia.org/wiki/Eulerian_path"&gt;Eulerian path&lt;/a&gt;
and it exists if and only if each vertex has the same in-degree and
out-degree and all vertices with non-zero degree belong to a single
strongly connected component.&lt;/p&gt;
&lt;p&gt;To find the path that we want in the graph that we created, we use
Hierholzer's algorithm:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We pick a starting node, &lt;span class="math"&gt;\(u\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;We go from node to node until we return to &lt;span class="math"&gt;\(u\)&lt;/span&gt;. The path that we
  have traced to this point does not necessarily cover all edges.&lt;/li&gt;
&lt;li&gt;As long as there exists a vertex &lt;span class="math"&gt;\(v\)&lt;/span&gt; that belongs to the path we
  have traced, but is part of an edge that does not belong to that
  path:&lt;ul&gt;
&lt;li&gt;We start another path from &lt;span class="math"&gt;\(v\)&lt;/span&gt;, using edges that we have not used
  yet, until we return to &lt;span class="math"&gt;\(v\)&lt;/span&gt;. Then we splice this path to the path
  we have already traced.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we use the algorithm in our example graph, we will find the path in
the following figure:&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="https://louridas.github.io/assignments/genome-assembly/fragment_graph_path.png" width="400"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;If we go along the path and we connect the vertices keeping their
common base only once we get the DNA sequence ATGGCGTGCA. Note that
the sequence is cyclical: the vertex AA occurs in the sequence if we
connect its end with its beginning. That means that an equivalent
sequence is GGCGTGCAAT, or any other that is a rotation of ATGGCGTGCA.
Moreover, depending on the starting node &lt;span class="math"&gt;\(u\)&lt;/span&gt; and how we choose an edge
when we have more than one outgoing vertices, we may get a different
sequence. For example, if we start from TG we may get the sequence
TGGCAATGCG or any other that is a rotation of TGGCAATGCG. That is OK.
In the following figures you can see the cyclical character of the
sequences:&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="https://louridas.github.io/assignments/genome-assembly/dna_circular_1.png" width="300"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;img src="https://louridas.github.io/assignments/genome-assembly/dna_circular_2.png" width="300"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;The purpose of this assignment is to create a program that assembles
DNA from a set of fragments. For more details, see &lt;a href='#compeau:2011' id='ref-compeau:2011-1'&gt;[1]&lt;/a&gt; and
&lt;a href='#pevzner:2001' id='ref-pevzner:2001-1'&gt;[3]&lt;/a&gt;. Hierholzer's algorithm was originally published in
1873 &lt;a href='#hierholzer:1873' id='ref-hierholzer:1873-1'&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Requirements&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;You will write a program named &lt;code&gt;dna_assembly.py&lt;/code&gt; that performs DNA
   assembly. &lt;/li&gt;
&lt;li&gt;You will not use ready-made graph libraries.&lt;/li&gt;
&lt;li&gt;Your program must be called as follows:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python  dna_assembly.py fragments_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;fragments_file&lt;/code&gt; argument specifies the name of the file where the
DNA fragments are stored. The file will have the
following format:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ATG
GTG
TGG
GGC
GCG
CGT
GCA
TGC
CAA
AAT
ATG
AAT
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;that is, it contains one polymer per line.&lt;/p&gt;
&lt;h3&gt;Output&lt;/h3&gt;
&lt;p&gt;The program's output will be the DNA sequence that it assembled.&lt;/p&gt;
&lt;h3&gt;Examples&lt;/h3&gt;
&lt;p&gt;The fragments for the example that we have been using is in the file
&lt;a href="https://louridas.github.io/assignments/genome-assembly/fragment_file_1.txt"&gt;fragment_file_1.txt&lt;/a&gt;, so the output will
be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ATGGCGTGCA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;or some other equivalent sequence, as explained above.&lt;/p&gt;
&lt;p&gt;If the user gives the file
&lt;a href="https://louridas.github.io/assignments/genome-assembly/fragment_file_2.txt"&gt;fragment_file_2.txt&lt;/a&gt; the output will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;AGTGGACCATGTATACTTCA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;or some other equivalent, such as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;TGTACTTCATATGGACCAAG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If the user gives the file
&lt;a href="https://louridas.github.io/assignments/genome-assembly/fragment_file_3.txt"&gt;fragment_file_3.txt&lt;/a&gt; the output will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ATCTCAGACTTACACCATATGG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;or some other equivalent, such as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;TCTCAGACTTACACCATATGGA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If the user gives the file
&lt;a href="https://louridas.github.io/assignments/genome-assembly/fragment_file_4.txt"&gt;fragments_file_4.txt&lt;/a&gt; the output will
be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;GACTACCTGGTCTCGATCACGGA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;or some other equivalent, such as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;CGGTCACTCTGGACCTACGAGAT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;or:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;TACTCGGACGAGATCACCTGGTC
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If you want to verify the results, you can write some code that checks
that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;All the fragments in the input file are present in the output
   sequence.&lt;/li&gt;
&lt;li&gt;All the fragments in the sequence are present in the input file.&lt;/li&gt;
&lt;/ol&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;hr&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;div class='bibliography'&gt;&lt;ol&gt;&lt;li id='compeau:2011'&gt;Phillip E&amp;nbsp;C Compeau, Pavel&amp;nbsp;A Pevzner, and Glenn Tesler.
How to apply de &lt;span class="bibtex-protected"&gt;Bruijn&lt;/span&gt; graphs to genome assembly.
&lt;em&gt;Nature Biotechnology&lt;/em&gt;, 29(11):987–991, 11 2011.
URL: &lt;a href="http://dx.doi.org/10.1038/nbt.2023"&gt;http://dx.doi.org/10.1038/nbt.2023&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-compeau:2011-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='hierholzer:1873'&gt;Carl Hierholzer.
Ueber die &lt;span class="bibtex-protected"&gt;M&lt;/span&gt;öglichkeit, einen &lt;span class="bibtex-protected"&gt;L&lt;/span&gt;inienzug ohne &lt;span class="bibtex-protected"&gt;W&lt;/span&gt;iederholung und ohne &lt;span class="bibtex-protected"&gt;U&lt;/span&gt;nterbrechung zu umfahren.
&lt;em&gt;Mathematische Annalen&lt;/em&gt;, 6(1):30–32, 1873. &lt;a class="cite-backref" href="#ref-hierholzer:1873-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='pevzner:2001'&gt;Pavel&amp;nbsp;A. Pevzner, Haixu Tang, and Michael&amp;nbsp;S. Waterman.
An &lt;span class="bibtex-protected"&gt;E&lt;/span&gt;ulerian path approach to &lt;span class="bibtex-protected"&gt;DNA&lt;/span&gt; fragment assembly.
&lt;em&gt;Proceedings of the National Academy of Sciences&lt;/em&gt;, 98(17):9748–9753, 2001.
URL: &lt;a href="http://www.pnas.org/content/98/17/9748.abstract"&gt;http://www.pnas.org/content/98/17/9748.abstract&lt;/a&gt;, &lt;a href="https://arxiv.org/abs/http://www.pnas.org/content/98/17/9748.full.pdf"&gt;arXiv:http://www.pnas.org/content/98/17/9748.full.pdf&lt;/a&gt;, &lt;a href="https://doi.org/10.1073/pnas.171285098"&gt;doi:10.1073/pnas.171285098&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-pevzner:2001-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><category term="assignments"></category></entry><entry><title>Musical Rhythms</title><link href="https://louridas.github.io/assignments/musical-rhythms/" rel="alternate"></link><published>2017-08-02T00:00:00+03:00</published><updated>2017-08-02T00:00:00+03:00</updated><author><name>Panos Louridas</name></author><id>tag:louridas.github.io,2017-08-02:/assignments/musical-rhythms/</id><summary type="html">&lt;p&gt;Consider the following problem. You want to create a binary sequence
of &lt;span class="math"&gt;\(n\)&lt;/span&gt; bits, out of which &lt;span class="math"&gt;\(k\)&lt;/span&gt; are one (and the rest are of course
zero). You also want the ones to be as evenly spread as possible among
the zeroes. If &lt;span class="math"&gt;\(k\)&lt;/span&gt; divides &lt;span class="math"&gt;\(n\)&lt;/span&gt;, then the solution is …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Consider the following problem. You want to create a binary sequence
of &lt;span class="math"&gt;\(n\)&lt;/span&gt; bits, out of which &lt;span class="math"&gt;\(k\)&lt;/span&gt; are one (and the rest are of course
zero). You also want the ones to be as evenly spread as possible among
the zeroes. If &lt;span class="math"&gt;\(k\)&lt;/span&gt; divides &lt;span class="math"&gt;\(n\)&lt;/span&gt;, then the solution is straightforward;
we just divide the ones among the zeros. For example, for &lt;span class="math"&gt;\(n = 16\)&lt;/span&gt; and
&lt;span class="math"&gt;\(k = 4\)&lt;/span&gt; we get the sequence:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[ 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The problem gets more interesting when &lt;span class="math"&gt;\(n\)&lt;/span&gt; and &lt;span class="math"&gt;\(k\)&lt;/span&gt; are relatively
prime, that is, when the only common divisor of &lt;span class="math"&gt;\(n\)&lt;/span&gt; and &lt;span class="math"&gt;\(k\)&lt;/span&gt; is the
number 1.&lt;/p&gt;
&lt;p&gt;So suppose that we have &lt;span class="math"&gt;\(n = 13\)&lt;/span&gt; and &lt;span class="math"&gt;\(k = 5\)&lt;/span&gt;. As we have &lt;span class="math"&gt;\(13 - 5 = 8\)&lt;/span&gt;,
we start by creating a sequence with 5 ones and 8 zeroes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[ 1 1 1 1 1 0 0 0 0 0 0 0 0 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We can treat this sequence as 13 sequences of one bit each:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[ [1] [1] [1] [1] [1] [0] [0] [0] [0] [0] [0] [0] [0] ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We distribute the zeroes so that we get five sequences of two bits
each, and three sequences of one bit:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[ [1 0] [1 0] [1 0] [1 0] [1 0] [0] [0] [0] ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Then we distribute the remaining zeroes in the same way, so that we
get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[ [1 0 0] [1 0 0] [1 0 0] [1 0] [1 0] ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now we distribute the &lt;code&gt;[1 0]&lt;/code&gt; sequences, which leads to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[ [1 0 0 1 0] [1 0 0 1 0] [1 0 0] ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The process ends when the remainder (that is, the sequences with the
smallest number of bits) is exactly one, or we do not have any more
zeroes to distribute. Then we concatenate the result. In our example,
we get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[ 1 0 0 1 0 1 0 0 1 0 1 0 0 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We can interpret the above sequence as a rhythm, where each digit is a
unit of time and each &lt;code&gt;0&lt;/code&gt; shows a silence (or unaccented note), while
each &lt;code&gt;1&lt;/code&gt; shows an attack, or an onset of a note. Then, for different
relatively prime &lt;span class="math"&gt;\(n\)&lt;/span&gt; and &lt;span class="math"&gt;\(k\)&lt;/span&gt; we get a wealth of rhythms that are used
in world music. Two examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The rhythm with &lt;span class="math"&gt;\(k = 3\)&lt;/span&gt; and &lt;span class="math"&gt;\(n = 7\)&lt;/span&gt;, &lt;span class="math"&gt;\([\ 1\ 0\ 1\ 0\ 1\ 0\ 0\ ]\)&lt;/span&gt;, is
  the Ruchenitza (Rachenitsa, Ръченица, Rŭchenitsa, Râčenica) rhythm
  that is used in Bulgarian folk musing and in the
  &lt;a href="https://en.wikipedia.org/wiki/Pink_Floyd"&gt;Pink Floyd&lt;/a&gt; song
  &lt;a href="https://en.wikipedia.org/wiki/Money_(Pink_Floyd_song)"&gt;Money&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The rhythm with &lt;span class="math"&gt;\(k = 5\)&lt;/span&gt; and &lt;span class="math"&gt;\(n = 9\)&lt;/span&gt;,
  &lt;span class="math"&gt;\([\ 1\ 0\ 1\ 0\ 1\ 0\ 1\ 0\ 1\ ]\)&lt;/span&gt;,
  is a popular Arabic rhythm called Agsag Samai. If started on the second
  onset, it is drum pattern used by the
  &lt;a href="https://en.wikipedia.org/wiki/Venda_people"&gt;Venda people&lt;/a&gt; in South
  Africa, as well as a Romanian folk dance. It is also the rhythm
  pattern of the Greek Sigaktistos.
  [ This is according to the bibliography. The author, being Greek,
  does not know any rhythm by that name. A student, Marios Pitsalidis,
  suggested that perhaps the correct name is Sigkathistos, Συγκαθιστός,
  meaning "sitting together," which probably makes sense. If somebody
  knows more, please contact the author. ] The Turkish Samai Aktsak
  follows the same pattern as well. If started on the third onset, it
  is the rhythmical pattern of the Turkish Nawahiid rhythm.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Euclidean Rhythms and Euclidean Strings&lt;/h3&gt;
&lt;p&gt;The way we outlined for constructing these rhythmical sequences for
different &lt;span class="math"&gt;\(k\)&lt;/span&gt; and &lt;span class="math"&gt;\(n\)&lt;/span&gt; follows Euclid's algorithm for finding the
greatest common divisor of two numbers. Indeed, if &lt;code&gt;euclid(n, k)&lt;/code&gt; is a
function implementing the algorithm, we would have &lt;code&gt;euclid(8,5) =
euclid(5,3) = euclid(3,2) = euclid(2,1) = euclid(1,0) = 1&lt;/code&gt;, which
corresponds to the steps we made. For that reason, these rhythms are
called
&lt;a href="https://en.wikipedia.org/wiki/Euclidean_rhythm"&gt;Euclidean rhythms&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;To describe a Euclidean rhythm we use the &lt;span class="math"&gt;\(E(k, n)\)&lt;/span&gt; notation, where
&lt;span class="math"&gt;\(k\)&lt;/span&gt; is the number of onsets and &lt;span class="math"&gt;\(n\)&lt;/span&gt; is the length of the rhythm, for
example &lt;span class="math"&gt;\(E(5, 9)\)&lt;/span&gt;. We can also use another notation, in which we count
the intervals until the next onset, so we have &lt;span class="math"&gt;\(E(5, 9) = (22221)\)&lt;/span&gt;,
because there are two between the first and the second onset in
&lt;span class="math"&gt;\([\ 1\ 0\ 1\ 0\ 1\ 0\ 1\ 0\ 1\ ]\)&lt;/span&gt;, and so on. Another rhythm is &lt;span class="math"&gt;\(E(5, 12)\)&lt;/span&gt;,
which corresponds to &lt;span class="math"&gt;\([\ 1\ 0\ 0\ 1\ 0\ 1\ 0\ 0\ 1\ 0\ 1\ 0\ ]\)&lt;/span&gt; and
can also be written &lt;span class="math"&gt;\((32322)\)&lt;/span&gt;, as you may check. The second notation
is called &lt;em&gt;adjacent-inter-onset-interval vector&lt;/em&gt;, or &lt;em&gt;interval vector&lt;/em&gt;
for short. In essence, an interval vector is a sequence of positive
integers.&lt;/p&gt;
&lt;p&gt;If we have a rhythm written in interval vector notation, say, &lt;code&gt;P =
(p[0], p[1] , ... , p[n−1])&lt;/code&gt;, then if we increase &lt;code&gt;p[0]&lt;/code&gt; by one and
decrease &lt;code&gt;p[n-1]&lt;/code&gt; by one, we will get a new interval vector. If this
new interval vector can also result by rotating the first one, then we
say that we have a &lt;em&gt;Euclidean string&lt;/em&gt;. For example, &lt;span class="math"&gt;\(E(4, 9)\)&lt;/span&gt; is
&lt;span class="math"&gt;\([\ 1\ 0\ 1\ 0\ 1\ 0\ 1\ 0\ 0\ ]\)&lt;/span&gt; and &lt;span class="math"&gt;\((2223)\)&lt;/span&gt;. If we increase the first
digit by one and we decrease the last digit by one, we get &lt;span class="math"&gt;\((3222)\)&lt;/span&gt;,
which we can get by rotating the first string, so the rhythm is also a
Euclidean string.&lt;/p&gt;
&lt;p&gt;If we take the reverse string from an interval vector, that is, if we
read it from the end to the start, and we the reverse string is also a
Euclidean string, then we say that we have a &lt;em&gt;reverse Euclidean
string&lt;/em&gt;. For example, &lt;span class="math"&gt;\(E(4, 11)\)&lt;/span&gt; is
&lt;span class="math"&gt;\([\ 1\ 0\ 0\ 1\ 0\ 0\ 1\ 0\ 0\ 1\ 0\ ]\)&lt;/span&gt; and &lt;span class="math"&gt;\((3332)\)&lt;/span&gt;. The reverse
string of the interval vector is &lt;span class="math"&gt;\((2333)\)&lt;/span&gt;, which is a Euclidean
string, so &lt;span class="math"&gt;\((3332)\)&lt;/span&gt; is a reverse Euclidean string.&lt;/p&gt;
&lt;p&gt;For more information on Euclidean rhythms check &lt;a href='#toussaint:2005' id='ref-toussaint:2005-1'&gt;[4]&lt;/a&gt;;
&lt;a href="https://en.wikipedia.org/wiki/Godfried_Toussaint"&gt;Godfried Toussaint&lt;/a&gt;
was the one that introduced the concept and has written a whole book
on the geometry of musical rhythm &lt;a href='#toussaint:2013' id='ref-toussaint:2013-1'&gt;[6]&lt;/a&gt;. See also
&lt;a href='#demaine:2009' id='ref-demaine:2009-1'&gt;[2]&lt;/a&gt; for a well-developed overview. For more information on
Euclidean strings, see &lt;a href='#ellis:2003' id='ref-ellis:2003-1'&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Distance between Rhythms&lt;/h3&gt;
&lt;p&gt;How different are two rhythms? If we take two rhythms are binary
sequences, then one metric that we can use to gauge the distance
between two strings of equal length is the number of positions in
which the corresponding elements of the sequences are different. This
is called
&lt;a href="https://en.wikipedia.org/wiki/Hamming_distance"&gt;Hamming distance&lt;/a&gt;. If
&lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; are two sequences, the following function (adapted for
Python 3 from
the Wikipedia article), calculates the Hamming distance:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hamming_distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;ValueError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Undefined for sequences of unequal length&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ch1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nb"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ch2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;ch1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ch2&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For example, the rhythm &lt;span class="math"&gt;\(E(4, 9) = [\ 1\ 0\ 1\ 0\ 1\ 0\ 1\ 0\ 0\ ]\)&lt;/span&gt;
has a Hamming distance of one from the rhythm &lt;span class="math"&gt;\(E(5, 9) =
[\ 1\ 0\ 1\ 0\ 1\ 0\ 1\ 0\ 1\ ]\)&lt;/span&gt; and a Hamming distance of three from
the rhythm &lt;span class="math"&gt;\(E(7, 9) = [\ 1\ 0\ 1\ 1\ 1\ 0\ 1\ 1\ 1\ ]\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;That said, the Hamming distance is not the best way to measure the
similarity of rhythms. There are better metrics for that purpose
&lt;a href='#toussaint:2004' id='ref-toussaint:2004-1'&gt;[5]&lt;/a&gt; &lt;a href='#toussaint:2013' id='ref-toussaint:2013-2'&gt;[6]&lt;/a&gt;, but we'll stick to the Hamming
distance for now.&lt;/p&gt;
&lt;p&gt;In this assignment you will develop a program that handles and
manipulates Euclidean rhythms.&lt;/p&gt;
&lt;h3&gt;Requirements&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;You will write a program called &lt;code&gt;musical_rhythms.py&lt;/code&gt;, which will
   work with Euclidean rhythms.&lt;/li&gt;
&lt;li&gt;The program will read, upon start, the dictionary of rhythms that
   is stored in the file
   &lt;a href="https://louridas.github.io/assignments/musical-rhythms/musical_rhythms.json"&gt;musical_rhythms.json&lt;/a&gt;. The file
   should be stored in the same directory as the program itself. The
   contents of the file are in
   &lt;a href="http://www.json.org/"&gt;JSON (JavaScript Object Notation)&lt;/a&gt;, so you
   should use the
   &lt;a href="https://docs.python.org/3/library/json.html"&gt;Python &lt;code&gt;json&lt;/code&gt; library&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Your program must be called as follows:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python musical_rhythms.py &lt;span class="o"&gt;[&lt;/span&gt;-s SLOTS&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-p PULSES&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-r RECOGNIZE&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-l LIST_RHYTHMS&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Output&lt;/h3&gt;
&lt;h4&gt;Create a Rhythm&lt;/h4&gt;
&lt;p&gt;If the user gives the parameters &lt;code&gt;-s SLOTS&lt;/code&gt; and &lt;code&gt;-p PULSES&lt;/code&gt;, then
&lt;code&gt;SLOTS&lt;/code&gt; and &lt;code&gt;PULSES&lt;/code&gt; will be positive integers. The program will then
return information on the rhythm that corresponds to these parameters, where
&lt;code&gt;PULSES&lt;/code&gt; is the number of onsets and &lt;code&gt;SLOTS&lt;/code&gt; is the length of the
rhythm. To do that, the program will look up the rhythm in the rhythm
dictionary. If it finds it there, it will display the information
stored for that rhythm; otherwise, it will just display the rhythm. In
the next line, if the rhythm corresponds to a Euclidean string or to a
reverse Euclidean string, it will display an appropriate message.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python musical_rhythms.py -s &lt;span class="m"&gt;12&lt;/span&gt; -p &lt;span class="m"&gt;6&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;6&lt;/span&gt;,12&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;101010101010&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;222222&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python musical_rhythms.py -s &lt;span class="m"&gt;12&lt;/span&gt; -p &lt;span class="m"&gt;7&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt;,12&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;101101011010&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;2122122&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; It is a common West African bell pattern. For example, it is used in the Mpre rhythm of the Ashanti people of Ghana. Started on the seventh &lt;span class="o"&gt;(&lt;/span&gt;last&lt;span class="o"&gt;)&lt;/span&gt; onset, it is a Yoruba bell pattern of Nigeria, a Babenzele pattern of Central Africa, and a Mende pattern of Sierra Leone.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python musical_rhythms.py -s &lt;span class="m"&gt;16&lt;/span&gt; -p &lt;span class="m"&gt;5&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;,16&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1001001001001000&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;33334&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; It is the Bossa-Nova rhythm necklace of Brazil. The actual Bossa-Nova rhythm usually starts on the third onset as follows: &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1001001000100100&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;. However, other starting places are also documented in world music practices, such as &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1001001001000100&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;.
It is a Euclidean string.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python musical_rhythms.py -s &lt;span class="m"&gt;9&lt;/span&gt; -p &lt;span class="m"&gt;5&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;,9&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;101010101&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;22221&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; It is a popular Arabic rhythm called Agsag-Samai. Started on the second onset, it is a drum pattern used by the Venda in South Africa, as well as a Rumanian folk-dance rhythm. It is also the rhythmic pattern of the Sigaktistos rhythm of Greece, and the Samai aktsak rhythm of Turkey. Started on the third onset, it is the rhythmic pattern of the Nawahiid rhythm of Turkey.
It is a reverse Euclidean string.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As you can see, the first thing to appear will be rhythm in the form
&lt;span class="math"&gt;\(E(k, n)\)&lt;/span&gt;; then as a binary string inside square brackets; then as
interval vector inside parentheses; and then any description found in
the rhythms dictionary. The final line will contain a message if it is
a Euclidean or a reverse Euclidean string.&lt;/p&gt;
&lt;h4&gt;Rhythm Recognition&lt;/h4&gt;
&lt;p&gt;If the user gives the parameter &lt;code&gt;-r RECOGNIZE&lt;/code&gt;, then &lt;code&gt;RECOGNIZE&lt;/code&gt; will
be a rhythm represented as a binary string and the program should
identify it, if it is a Euclidean rhythm, and print out any
information available. If it is not a Euclidean rhythm, it should
print an appropriate message.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python musical_rhythms.py -r &lt;span class="m"&gt;101101011010&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt;,12&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;101101011010&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;2122122&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; It is a common West African bell pattern. For example, it is used in the Mpre rhythm of the Ashanti people of Ghana. Started on the seventh &lt;span class="o"&gt;(&lt;/span&gt;last&lt;span class="o"&gt;)&lt;/span&gt; onset, it is a Yoruba bell pattern of Nigeria, a Babenzele pattern of Central Africa, and a Mende pattern of Sierra Leone.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python musical_rhythms.py -r &lt;span class="m"&gt;10010010010&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;,11&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;10010010010&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;3332&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; It is the metric pattern used by Frank Zappa in his piece titled Outside Now.
It is a reverse Euclidean string.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python musical_rhythms.py -r &lt;span class="m"&gt;10010010011&lt;/span&gt;
Not a Euclidean rhythm.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;Show Similar Rhythms&lt;/h4&gt;
&lt;p&gt;If the user gives the parameter &lt;code&gt;-l LIST_RHYTHMS&lt;/code&gt;, then &lt;code&gt;LIST_RHYTHMS&lt;/code&gt;
will be a rhythm given as a binary string and the program will display
all rhythms of the same length, ordered in increasing Hamming distance
and number of onsets.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python musical_rythms.py -l &lt;span class="m"&gt;101010100&lt;/span&gt;
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;,9&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;101010100&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;2223&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; It is the Aksak rhythm of Turkey. It is also the metric pattern used by Dave Brubeck in his piece Rondo a la Turk.
It is a Euclidean string.
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;,9&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;101010101&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;22221&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; It is a popular Arabic rhythm called Agsag-Samai. Started on the second onset, it is a drum pattern used by the Venda in South Africa, as well as a Rumanian folk-dance rhythm. It is also the rhythmic pattern of the Sigaktistos rhythm of Greece, and the Samai aktsak rhythm of Turkey. Started on the third onset, it is the rhythmic pattern of the Nawahiid rhythm of Turkey.
It is a reverse Euclidean string.
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;,9&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;100010000&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;45&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
It is a Euclidean string.
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;,9&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;100000000&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;9&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;,9&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;100100100&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;333&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt;,9&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;101110111&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;2112111&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; It is the Bazaragana rhythmic pattern of Greece.
It is a reverse Euclidean string.
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;4&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;6&lt;/span&gt;,9&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;101101101&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;212121&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;4&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt;,9&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;101111111&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;21111111&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
It is a reverse Euclidean string.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python musical_rythms.py -l &lt;span class="m"&gt;1001001001000&lt;/span&gt;
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;,13&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1001001001000&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;3334&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
It is a Euclidean string.
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;,13&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1000001000000&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;67&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
It is a Euclidean string.
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;,13&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1000000000000&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;13&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;5&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;,13&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1000100010000&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;445&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
It is a Euclidean string.
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;5&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;,13&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1001010010100&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;32323&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; It is a rhythm from the FYROM which is also played by starting it on the fourth onset as follows: &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1010010010100&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;.
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;5&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;9&lt;/span&gt;,13&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1011011011011&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;212121211&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
It is a reverse Euclidean string.
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;6&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;6&lt;/span&gt;,13&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1010101010100&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;222223&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; It is the rhythm of the dance Mama Cone pita from the FYROM. Started on the third onset, it is the rhythm of the dance Postupano Oro from the FYROM, as well as the Krivo Plovdivsko Horo of Bulgaria.
It is a Euclidean string.
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;7&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt;,13&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1010101010101&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;2222221&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
It is a reverse Euclidean string.
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;7&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;11&lt;/span&gt;,13&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1011111011111&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;21111211111&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
It is a reverse Euclidean string.
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;8&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt;,13&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1011010110101&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;21221221&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;8&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;,13&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1011101110111&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;2112112111&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
It is a reverse Euclidean string.
&lt;span class="nv"&gt;Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;8&lt;/span&gt;
E&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;12&lt;/span&gt;,13&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1011111111111&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;211111111111&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
It is a reverse Euclidean string.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Notes on Implementation&lt;/h3&gt;
&lt;p&gt;The rhythms can be constructed using an algorithm with repeated
division, following the logic of Euclid's algorithm. That algorithm is
called the Bjorklund algorithm, after the name of the researcher that
noticed such patterns in neutron experiments in the
&lt;a href="https://en.wikipedia.org/wiki/Spallation_Neutron_Source"&gt;Spallation Neutron Source&lt;/a&gt;
&lt;a href='#bjorklund:1999' id='ref-bjorklund:1999-1'&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Do not use the Bjorklund algorithm to solve the assignment. Develop
 your solutions manipulating lists, as is described here.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you want to verify your results, you may wish to check the
Euclidean rhythms in &lt;a href='#toussaint:2005' id='ref-toussaint:2005-2'&gt;[4]&lt;/a&gt; and &lt;a href='#demaine:2009' id='ref-demaine:2009-2'&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;hr&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;div class='bibliography'&gt;&lt;ol&gt;&lt;li id='bjorklund:1999'&gt;E.&amp;nbsp;Bjorklund.
The theory of rep-rate pattern generation in the &lt;span class="bibtex-protected"&gt;SNS&lt;/span&gt; timing system.
Technical Report SNS-NOTE-CNTRL-99, Spallation Neutron Source, 1999.
URL: &lt;a href="https://ics-web.sns.ornl.gov/timing/Rep-Rate%20Tech%20Note.pdf"&gt;https://ics-web.sns.ornl.gov/timing/Rep-Rate%20Tech%20Note.pdf&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-bjorklund:1999-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='demaine:2009'&gt;Erik&amp;nbsp;D. Demaine, Francisco Gomez-Martin, Henk Meijer, David Rappaport, Perouz Taslakian, Godfried&amp;nbsp;T. Toussaint, Terry Winograd, and David&amp;nbsp;R. Wood.
The distance geometry of music.
&lt;em&gt;Computational Geometry: Theory and Applications&lt;/em&gt;, 42(5):429–454, July 2009.
URL: &lt;a href="http://erikdemaine.org/papers/DeepRhythms_CGTA/paper.pdf"&gt;http://erikdemaine.org/papers/DeepRhythms_CGTA/paper.pdf&lt;/a&gt;.&lt;a class="cite-backref" href="#ref-demaine:2009-1" title="Jump back to reference 1"&gt; &lt;sup&gt;1&lt;/sup&gt; &lt;/a&gt;&lt;a class="cite-backref" href="#ref-demaine:2009-2" title="Jump back to reference 2"&gt;&lt;sup&gt;2&lt;/sup&gt; &lt;/a&gt;&lt;/li&gt;&lt;li id='ellis:2003'&gt;John Ellis, Frank Ruskey, Joe Sawada, and Jamie Simpson.
Euclidean strings.
&lt;em&gt;Theoretical Computer Science&lt;/em&gt;, 301(1):321–340, 2003.
URL: &lt;a href="http://www.socs.uoguelph.ca/~sawada/papers/euclid.pdf"&gt;http://www.socs.uoguelph.ca/~sawada/papers/euclid.pdf&lt;/a&gt;, &lt;a href="https://doi.org/http://dx.doi.org/10.1016/S0304-3975(02)00589-3"&gt;doi:http://dx.doi.org/10.1016/S0304-3975(02)00589-3&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-ellis:2003-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='toussaint:2005'&gt;Godfried Toussaint.
The &lt;span class="bibtex-protected"&gt;Euclidean&lt;/span&gt; algorithm generates traditional musical rhythms.
In &lt;em&gt;BRIDGES: Mathematical Connections in Art, Music, and Science&lt;/em&gt;, 47–56. July 31 to August 3 20015.
URL: &lt;a href="http://cgm.cs.mcgill.ca/~godfried/publications/banff.pdf"&gt;http://cgm.cs.mcgill.ca/~godfried/publications/banff.pdf&lt;/a&gt;.&lt;a class="cite-backref" href="#ref-toussaint:2005-1" title="Jump back to reference 1"&gt; &lt;sup&gt;1&lt;/sup&gt; &lt;/a&gt;&lt;a class="cite-backref" href="#ref-toussaint:2005-2" title="Jump back to reference 2"&gt;&lt;sup&gt;2&lt;/sup&gt; &lt;/a&gt;&lt;/li&gt;&lt;li id='toussaint:2004'&gt;Godfried Toussaint.
The geometry of musical rhythm.
In &lt;em&gt;Proceedings of the 2004 Japanese Conference on Discrete and Computational Geometry&lt;/em&gt;, JCDCG'04, 198–212. Berlin, Heidelberg, 2005. Springer-Verlag.
URL: &lt;a href="http://cgm.cs.mcgill.ca/~godfried/publications/geometry-of-rhythm.pdf"&gt;http://cgm.cs.mcgill.ca/~godfried/publications/geometry-of-rhythm.pdf&lt;/a&gt;, &lt;a href="https://doi.org/10.1007/11589440_20"&gt;doi:10.1007/11589440_20&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-toussaint:2004-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='toussaint:2013'&gt;Godfried&amp;nbsp;T. Toussaint.
&lt;em&gt;The Geometry of Musical Rhythm: What Makes a "Good" Rhythm Good?&lt;/em&gt;
CRC Press, Taylor &amp;amp; Francis Group, Boca Raton, FL, 2013.&lt;a class="cite-backref" href="#ref-toussaint:2013-1" title="Jump back to reference 1"&gt; &lt;sup&gt;1&lt;/sup&gt; &lt;/a&gt;&lt;a class="cite-backref" href="#ref-toussaint:2013-2" title="Jump back to reference 2"&gt;&lt;sup&gt;2&lt;/sup&gt; &lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><category term="assignments"></category></entry><entry><title>Finding Trusses</title><link href="https://louridas.github.io/assignments/finding-trusses/" rel="alternate"></link><published>2017-07-31T00:00:00+03:00</published><updated>2017-07-31T00:00:00+03:00</updated><author><name>Panos Louridas</name></author><id>tag:louridas.github.io,2017-07-31:/assignments/finding-trusses/</id><summary type="html">&lt;p&gt;Thanks to
&lt;a href="https://en.wikipedia.org/wiki/Edward_Snowden"&gt;Edward Snowden&lt;/a&gt; we
know much more than we used to about
the way intelligence services work. So,
&lt;a href="https://www.documentcloud.org/documents/2702948-Problem-Book-Redacted.html"&gt;one of the documents he leaked&lt;/a&gt;
concerns the research activities of
&lt;a href="https://en.wikipedia.org/wiki/Government_Communications_Headquarters"&gt;GCHQ (Government Communications Headquarters)&lt;/a&gt;.
Reading the document, we can see that they are interested in detecting
specific structures in graphs …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Thanks to
&lt;a href="https://en.wikipedia.org/wiki/Edward_Snowden"&gt;Edward Snowden&lt;/a&gt; we
know much more than we used to about
the way intelligence services work. So,
&lt;a href="https://www.documentcloud.org/documents/2702948-Problem-Book-Redacted.html"&gt;one of the documents he leaked&lt;/a&gt;
concerns the research activities of
&lt;a href="https://en.wikipedia.org/wiki/Government_Communications_Headquarters"&gt;GCHQ (Government Communications Headquarters)&lt;/a&gt;.
Reading the document, we can see that they are interested in detecting
specific structures in graphs. The nodes in these graphs are people
and the edges are links between them. The links may be communication
channels such as phone calls, e-mails, etc. A structure that seems of
particular interest to GCHQ is the &lt;em&gt;k-truss&lt;/em&gt;, an idea that seems to
come from the
&lt;a href="https://en.wikipedia.org/wiki/National_Security_Agency"&gt;National Security Agency&lt;/a&gt;, see
&lt;a href='#cohen:2008' id='ref-cohen:2008-1'&gt;[1]&lt;/a&gt; and &lt;a href='#cohen:2009' id='ref-cohen:2009-1'&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A k-truss in a graph is a subset of the graph such that every edge in
the subset is supported by at least &lt;span class="math"&gt;\(k - 2\)&lt;/span&gt; other edges that form
triangles with that particular edge. In other words, every edge in the
truss must be part of &lt;span class="math"&gt;\(k - 2\)&lt;/span&gt; triangles made up of nodes that are part
of the truss. For example, in the following figures you can see two
3-trusses in a graph. By definition, 3-trusses are the triangles of a
graph.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/finding-trusses/truss_3_1.png" width="300"&gt;
&lt;img src="https://louridas.github.io/assignments/finding-trusses/truss_3_2.png" width="300"&gt;&lt;/p&gt;
&lt;p&gt;Similarly, in the following figure you can see a 4-truss of a graph.
4-trusses are sets of such that every edge is part of two triangles
composed of nodes in the truss.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://louridas.github.io/assignments/finding-trusses/truss_4.png" width="400"&gt;&lt;/p&gt;
&lt;p&gt;A k-truss is &lt;em&gt;maximal&lt;/em&gt; when it is not a subgraph of another k-truss.
Here we want to find the maximal k-trusses of a graph.&lt;/p&gt;
&lt;h3&gt;Maximal Truss Finding Algorithm&lt;/h3&gt;
&lt;p&gt;How do we find the maximal k-trusses of a graph? One way is with the
following algorithm:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;find_maximal_k_trusses(g, k):
    until no change do
        for each edge e = (a,b) in g:
            if (size(intersection(neighbours(a), neighbours(b)) &amp;lt; k - 2:
                remove e from g
    return the connected components of the remaining graph
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the above algorithm, &lt;code&gt;g&lt;/code&gt; is the graph and &lt;code&gt;k&lt;/code&gt; is the truss size.
The function &lt;code&gt;neighbours(a)&lt;/code&gt; gives us the neighbours of node &lt;code&gt;a&lt;/code&gt;, the
function &lt;code&gt;intersection(s1, s2)&lt;/code&gt; finds the intersection of two sets
&lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, and the function &lt;code&gt;size(s)&lt;/code&gt; finds the size of the set
&lt;code&gt;s&lt;/code&gt;. The idea behind the algorithm is to reduce the graph so that in
the end the connected components of the graph are maximal k-trusses.
This algorithm is not very efficient, better ones do exist, but it
will do for this assignment.&lt;/p&gt;
&lt;h3&gt;Requirements&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;You will write a program named &lt;code&gt;trusses.py&lt;/code&gt; that finds the
   maximal k-trusses of a graph.&lt;/li&gt;
&lt;li&gt;You will represent the graph with adjacency lists, not with an
   adjacency matrix.&lt;/li&gt;
&lt;li&gt;You will not use ready-made graph libraries.&lt;/li&gt;
&lt;li&gt;Your program must be called as follows:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python trusses.py graph_file size_of_truss
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;graph_file&lt;/code&gt; argument specifies the name of the file where the
graph is stored. The file will have the
following format:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0 2
1 3 
2 4
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;that is, it contains lines each one of which has two numbers. If
the two numbers are &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, the graph will have an edge between
the nodes &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The graph is undirected, so we assume that
there always exists the reverse edge from &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. The nodes
will be always consecutive integers starting from 0, i.e.,
0, 1, 2, ... You cannot assume that the file contents are ordered
in any way.&lt;/p&gt;
&lt;p&gt;The argument &lt;code&gt;size_of_truss&lt;/code&gt; is the truss dimension, i.e., the &lt;span class="math"&gt;\(k\)&lt;/span&gt; in
k-truss.&lt;/p&gt;
&lt;h3&gt;Output&lt;/h3&gt;
&lt;p&gt;The program will print out the k-trusses of the graph, if they exist,
in the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[0, 1, 9]
[8, 10, 16]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That is, each line
will contain a truss inside square brackets, with the nodes separated by
commas and whitespace. Every k-truss will be output only once, and
the k-trusses will be output in order.&lt;/p&gt;
&lt;h3&gt;Examples&lt;/h3&gt;
&lt;p&gt;If the user gives:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python trusses.py graph_1.txt &lt;span class="m"&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;with the file &lt;a href="https://louridas.github.io/assignments/finding-trusses/graph_1.txt"&gt;graph_1.txt&lt;/a&gt;, which actually corresponds
to the graph of the first two figures with the 3-trusses above, the
output will be the one we gave just above:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[0, 1, 9]
[8, 10, 16]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If the user gives:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python trusses.py graph_2.txt &lt;span class="m"&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;with the file &lt;a href="https://louridas.github.io/assignments/finding-trusses/graph_2.txt"&gt;graph_2.txt&lt;/a&gt;, the output will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[3, 8, 9, 18]
[7, 11, 15, 21]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If the user gives:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python trusses.py graph_3.txt &lt;span class="m"&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;with the file &lt;a href="https://louridas.github.io/assignments/finding-trusses/graph_3.txt"&gt;graph_3.txt&lt;/a&gt;, the output will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[2, 5, 8, 9, 13, 14]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If the user gives:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python trusses.py graph_4.txt &lt;span class="m"&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;with the file &lt;a href="https://louridas.github.io/assignments/finding-trusses/graph_4.txt"&gt;graph_4.txt&lt;/a&gt;, the output will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;that is, all the nodes in the graph, whereas if the user gives:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python trusses.py graph_4.txt &lt;span class="m"&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;with the same file, the output will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[0, 1, 3, 4, 5, 6, 9, 11]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;which corresponds to the 4-truss figure we gave at the beginning.&lt;/p&gt;
&lt;p&gt;If you want to try a bigger example, if the user gives:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python trusses.py barabasi_albert_graph_1500.txt &lt;span class="m"&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;using the file
&lt;a href="https://louridas.github.io/assignments/finding-trusses/graph_5.txt"&gt;graph_5.txt&lt;/a&gt;, which contains 1500 nodes,
the output will be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[0, 3, 4, 5, 7, 9, 11, 15, 26]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;hr&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;div class='bibliography'&gt;&lt;ol&gt;&lt;li id='cohen:2008'&gt;Jonathan Cohen.
Trusses: cohesive subgraphs for social network analysis.
Technical Report, National Security Agency, 2008.
URL: &lt;a href="https://www.computer.org/cms/Computer.org/dl/mags/cs/2009/04/extras/msp2009040029s1.pdf"&gt;https://www.computer.org/cms/Computer.org/dl/mags/cs/2009/04/extras/msp2009040029s1.pdf&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-cohen:2008-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id='cohen:2009'&gt;Jonathan Cohen.
Graph twiddling in a &lt;span class="bibtex-protected"&gt;MapReduce&lt;/span&gt; world.
&lt;em&gt;Computing in Science and Engineering&lt;/em&gt;, 11(4):29–41, July 2009.
URL: &lt;a href="http://dx.doi.org/10.1109/MCSE.2009.120"&gt;http://dx.doi.org/10.1109/MCSE.2009.120&lt;/a&gt;, &lt;a href="https://doi.org/10.1109/MCSE.2009.120"&gt;doi:10.1109/MCSE.2009.120&lt;/a&gt;. &lt;a class="cite-backref" href="#ref-cohen:2009-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><category term="assignments"></category></entry></feed>